# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pywrapcp
else:
    import _pywrapcp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class DefaultPhaseParameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    CHOOSE_MAX_SUM_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_SUM_IMPACT
    CHOOSE_MAX_AVERAGE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_AVERAGE_IMPACT
    CHOOSE_MAX_VALUE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_VALUE_IMPACT
    SELECT_MIN_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MIN_IMPACT
    SELECT_MAX_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MAX_IMPACT
    NONE = _pywrapcp.DefaultPhaseParameters_NONE
    NORMAL = _pywrapcp.DefaultPhaseParameters_NORMAL
    VERBOSE = _pywrapcp.DefaultPhaseParameters_VERBOSE
    var_selection_schema = property(_pywrapcp.DefaultPhaseParameters_var_selection_schema_get, _pywrapcp.DefaultPhaseParameters_var_selection_schema_set)
    value_selection_schema = property(_pywrapcp.DefaultPhaseParameters_value_selection_schema_get, _pywrapcp.DefaultPhaseParameters_value_selection_schema_set)
    initialization_splits = property(_pywrapcp.DefaultPhaseParameters_initialization_splits_get, _pywrapcp.DefaultPhaseParameters_initialization_splits_set)
    run_all_heuristics = property(_pywrapcp.DefaultPhaseParameters_run_all_heuristics_get, _pywrapcp.DefaultPhaseParameters_run_all_heuristics_set)
    heuristic_period = property(_pywrapcp.DefaultPhaseParameters_heuristic_period_get, _pywrapcp.DefaultPhaseParameters_heuristic_period_set)
    heuristic_num_failures_limit = property(_pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_get, _pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_set)
    persistent_impact = property(_pywrapcp.DefaultPhaseParameters_persistent_impact_get, _pywrapcp.DefaultPhaseParameters_persistent_impact_set)
    random_seed = property(_pywrapcp.DefaultPhaseParameters_random_seed_get, _pywrapcp.DefaultPhaseParameters_random_seed_set)
    display_level = property(_pywrapcp.DefaultPhaseParameters_display_level_get, _pywrapcp.DefaultPhaseParameters_display_level_set)
    decision_builder = property(_pywrapcp.DefaultPhaseParameters_decision_builder_get, _pywrapcp.DefaultPhaseParameters_decision_builder_set)

    def __init__(self):
        _pywrapcp.DefaultPhaseParameters_swiginit(self, _pywrapcp.new_DefaultPhaseParameters())
    __swig_destroy__ = _pywrapcp.delete_DefaultPhaseParameters

# Register DefaultPhaseParameters in _pywrapcp:
_pywrapcp.DefaultPhaseParameters_swigregister(DefaultPhaseParameters)

class Solver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    INT_VAR_DEFAULT = _pywrapcp.Solver_INT_VAR_DEFAULT
    INT_VAR_SIMPLE = _pywrapcp.Solver_INT_VAR_SIMPLE
    CHOOSE_FIRST_UNBOUND = _pywrapcp.Solver_CHOOSE_FIRST_UNBOUND
    CHOOSE_RANDOM = _pywrapcp.Solver_CHOOSE_RANDOM
    CHOOSE_MIN_SIZE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MIN
    CHOOSE_MIN_SIZE_HIGHEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MIN
    CHOOSE_MIN_SIZE_LOWEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MAX
    CHOOSE_MIN_SIZE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MAX
    CHOOSE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_LOWEST_MIN
    CHOOSE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_HIGHEST_MAX
    CHOOSE_MIN_SIZE = _pywrapcp.Solver_CHOOSE_MIN_SIZE
    CHOOSE_MAX_SIZE = _pywrapcp.Solver_CHOOSE_MAX_SIZE
    CHOOSE_MAX_REGRET_ON_MIN = _pywrapcp.Solver_CHOOSE_MAX_REGRET_ON_MIN
    CHOOSE_PATH = _pywrapcp.Solver_CHOOSE_PATH
    INT_VALUE_DEFAULT = _pywrapcp.Solver_INT_VALUE_DEFAULT
    INT_VALUE_SIMPLE = _pywrapcp.Solver_INT_VALUE_SIMPLE
    ASSIGN_MIN_VALUE = _pywrapcp.Solver_ASSIGN_MIN_VALUE
    ASSIGN_MAX_VALUE = _pywrapcp.Solver_ASSIGN_MAX_VALUE
    ASSIGN_RANDOM_VALUE = _pywrapcp.Solver_ASSIGN_RANDOM_VALUE
    ASSIGN_CENTER_VALUE = _pywrapcp.Solver_ASSIGN_CENTER_VALUE
    SPLIT_LOWER_HALF = _pywrapcp.Solver_SPLIT_LOWER_HALF
    SPLIT_UPPER_HALF = _pywrapcp.Solver_SPLIT_UPPER_HALF
    SEQUENCE_DEFAULT = _pywrapcp.Solver_SEQUENCE_DEFAULT
    SEQUENCE_SIMPLE = _pywrapcp.Solver_SEQUENCE_SIMPLE
    CHOOSE_MIN_SLACK_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_MIN_SLACK_RANK_FORWARD
    CHOOSE_RANDOM_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_RANDOM_RANK_FORWARD
    INTERVAL_DEFAULT = _pywrapcp.Solver_INTERVAL_DEFAULT
    INTERVAL_SIMPLE = _pywrapcp.Solver_INTERVAL_SIMPLE
    INTERVAL_SET_TIMES_FORWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_FORWARD
    INTERVAL_SET_TIMES_BACKWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_BACKWARD
    TWOOPT = _pywrapcp.Solver_TWOOPT
    OROPT = _pywrapcp.Solver_OROPT
    RELOCATE = _pywrapcp.Solver_RELOCATE
    EXCHANGE = _pywrapcp.Solver_EXCHANGE
    CROSS = _pywrapcp.Solver_CROSS
    MAKEACTIVE = _pywrapcp.Solver_MAKEACTIVE
    MAKEINACTIVE = _pywrapcp.Solver_MAKEINACTIVE
    MAKECHAININACTIVE = _pywrapcp.Solver_MAKECHAININACTIVE
    SWAPACTIVE = _pywrapcp.Solver_SWAPACTIVE
    EXTENDEDSWAPACTIVE = _pywrapcp.Solver_EXTENDEDSWAPACTIVE
    PATHLNS = _pywrapcp.Solver_PATHLNS
    FULLPATHLNS = _pywrapcp.Solver_FULLPATHLNS
    UNACTIVELNS = _pywrapcp.Solver_UNACTIVELNS
    INCREMENT = _pywrapcp.Solver_INCREMENT
    DECREMENT = _pywrapcp.Solver_DECREMENT
    SIMPLELNS = _pywrapcp.Solver_SIMPLELNS
    GE = _pywrapcp.Solver_GE
    LE = _pywrapcp.Solver_LE
    EQ = _pywrapcp.Solver_EQ
    DELAYED_PRIORITY = _pywrapcp.Solver_DELAYED_PRIORITY
    VAR_PRIORITY = _pywrapcp.Solver_VAR_PRIORITY
    NORMAL_PRIORITY = _pywrapcp.Solver_NORMAL_PRIORITY

    def __init__(self, *args):
        _pywrapcp.Solver_swiginit(self, _pywrapcp.new_Solver(*args))

        self.__python_constraints = []



    __swig_destroy__ = _pywrapcp.delete_Solver

    def Parameters(self) -> "operations_research::ConstraintSolverParameters":
        return _pywrapcp.Solver_Parameters(self)

    @staticmethod
    def DefaultSolverParameters() -> "operations_research::ConstraintSolverParameters":
        return _pywrapcp.Solver_DefaultSolverParameters()

    def AddConstraint(self, c: "Constraint") -> "void":
        return _pywrapcp.Solver_AddConstraint(self, c)

    def Solve(self, *args) -> "bool":
        return _pywrapcp.Solver_Solve(self, *args)

    def NewSearch(self, *args) -> "void":
        return _pywrapcp.Solver_NewSearch(self, *args)

    def NextSolution(self) -> "bool":
        return _pywrapcp.Solver_NextSolution(self)

    def RestartSearch(self) -> "void":
        return _pywrapcp.Solver_RestartSearch(self)

    def EndSearch(self) -> "void":
        return _pywrapcp.Solver_EndSearch(self)

    def SolveAndCommit(self, *args) -> "bool":
        return _pywrapcp.Solver_SolveAndCommit(self, *args)

    def CheckAssignment(self, solution: "Assignment") -> "bool":
        return _pywrapcp.Solver_CheckAssignment(self, solution)

    def CheckConstraint(self, ct: "Constraint") -> "bool":
        return _pywrapcp.Solver_CheckConstraint(self, ct)

    def Fail(self) -> "void":
        return _pywrapcp.Solver_Fail(self)

    @staticmethod
    def MemoryUsage() -> "int64":
        return _pywrapcp.Solver_MemoryUsage()

    def WallTime(self) -> "int64":
        return _pywrapcp.Solver_WallTime(self)

    def Branches(self) -> "int64":
        return _pywrapcp.Solver_Branches(self)

    def Solutions(self) -> "int64":
        return _pywrapcp.Solver_Solutions(self)

    def Failures(self) -> "int64":
        return _pywrapcp.Solver_Failures(self)

    def AcceptedNeighbors(self) -> "int64":
        return _pywrapcp.Solver_AcceptedNeighbors(self)

    def Stamp(self) -> "uint64":
        return _pywrapcp.Solver_Stamp(self)

    def FailStamp(self) -> "uint64":
        return _pywrapcp.Solver_FailStamp(self)

    def IntVar(self, *args) -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IntVar(self, *args)

    def BoolVar(self, *args) -> "operations_research::IntVar *":
        return _pywrapcp.Solver_BoolVar(self, *args)

    def IntConst(self, *args) -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IntConst(self, *args)

    def Sum(self, vars: "std::vector< operations_research::IntVar * > const &") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_Sum(self, vars)

    def ScalProd(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_ScalProd(self, *args)

    def MonotonicElement(self, values: "operations_research::Solver::IndexEvaluator1", increasing: "bool", index: "IntVar") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_MonotonicElement(self, values, increasing, index)

    def Element(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_Element(self, *args)

    def IndexExpression(self, vars: "std::vector< operations_research::IntVar * > const &", value: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_IndexExpression(self, vars, value)

    def Min(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_Min(self, *args)

    def Max(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_Max(self, *args)

    def ConvexPiecewiseExpr(self, expr: "IntExpr", early_cost: "int64", early_date: "int64", late_date: "int64", late_cost: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_ConvexPiecewiseExpr(self, expr, early_cost, early_date, late_date, late_cost)

    def SemiContinuousExpr(self, expr: "IntExpr", fixed_charge: "int64", step: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_SemiContinuousExpr(self, expr, fixed_charge, step)

    def ConditionalExpression(self, condition: "IntVar", expr: "IntExpr", unperformed_value: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_ConditionalExpression(self, condition, expr, unperformed_value)

    def TrueConstraint(self) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_TrueConstraint(self)

    def FalseConstraint(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_FalseConstraint(self, *args)

    def IsEqualCstCt(self, var: "IntExpr", value: "int64", boolvar: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsEqualCstCt(self, var, value, boolvar)

    def IsEqualCstVar(self, var: "IntExpr", value: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsEqualCstVar(self, var, value)

    def IsEqualCt(self, v1: "IntExpr", v2: "IntExpr", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsEqualCt(self, v1, v2, b)

    def IsEqualVar(self, v1: "IntExpr", v2: "IntExpr") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsEqualVar(self, v1, v2)

    def IsDifferentCstCt(self, var: "IntExpr", value: "int64", boolvar: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsDifferentCstCt(self, var, value, boolvar)

    def IsDifferentCstVar(self, var: "IntExpr", value: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsDifferentCstVar(self, var, value)

    def IsDifferentVar(self, v1: "IntExpr", v2: "IntExpr") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsDifferentVar(self, v1, v2)

    def IsDifferentCt(self, v1: "IntExpr", v2: "IntExpr", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsDifferentCt(self, v1, v2, b)

    def IsLessOrEqualCstCt(self, var: "IntExpr", value: "int64", boolvar: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsLessOrEqualCstCt(self, var, value, boolvar)

    def IsLessOrEqualCstVar(self, var: "IntExpr", value: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsLessOrEqualCstVar(self, var, value)

    def IsLessOrEqualVar(self, left: "IntExpr", right: "IntExpr") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsLessOrEqualVar(self, left, right)

    def IsLessOrEqualCt(self, left: "IntExpr", right: "IntExpr", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsLessOrEqualCt(self, left, right, b)

    def IsGreaterOrEqualCstCt(self, var: "IntExpr", value: "int64", boolvar: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsGreaterOrEqualCstCt(self, var, value, boolvar)

    def IsGreaterOrEqualCstVar(self, var: "IntExpr", value: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsGreaterOrEqualCstVar(self, var, value)

    def IsGreaterOrEqualVar(self, left: "IntExpr", right: "IntExpr") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsGreaterOrEqualVar(self, left, right)

    def IsGreaterOrEqualCt(self, left: "IntExpr", right: "IntExpr", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsGreaterOrEqualCt(self, left, right, b)

    def IsGreaterCstCt(self, v: "IntExpr", c: "int64", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsGreaterCstCt(self, v, c, b)

    def IsGreaterCstVar(self, var: "IntExpr", value: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsGreaterCstVar(self, var, value)

    def IsGreaterVar(self, left: "IntExpr", right: "IntExpr") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsGreaterVar(self, left, right)

    def IsGreaterCt(self, left: "IntExpr", right: "IntExpr", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsGreaterCt(self, left, right, b)

    def IsLessCstCt(self, v: "IntExpr", c: "int64", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsLessCstCt(self, v, c, b)

    def IsLessCstVar(self, var: "IntExpr", value: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsLessCstVar(self, var, value)

    def IsLessVar(self, left: "IntExpr", right: "IntExpr") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsLessVar(self, left, right)

    def IsLessCt(self, left: "IntExpr", right: "IntExpr", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsLessCt(self, left, right, b)

    def SumLessOrEqual(self, vars: "std::vector< operations_research::IntVar * > const &", cst: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_SumLessOrEqual(self, vars, cst)

    def SumGreaterOrEqual(self, vars: "std::vector< operations_research::IntVar * > const &", cst: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_SumGreaterOrEqual(self, vars, cst)

    def SumEquality(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_SumEquality(self, *args)

    def ScalProdEquality(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_ScalProdEquality(self, *args)

    def ScalProdGreaterOrEqual(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_ScalProdGreaterOrEqual(self, *args)

    def ScalProdLessOrEqual(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_ScalProdLessOrEqual(self, *args)

    def MinEquality(self, vars: "std::vector< operations_research::IntVar * > const &", min_var: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_MinEquality(self, vars, min_var)

    def MaxEquality(self, vars: "std::vector< operations_research::IntVar * > const &", max_var: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_MaxEquality(self, vars, max_var)

    def ElementEquality(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_ElementEquality(self, *args)

    def AbsEquality(self, var: "IntVar", abs_var: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_AbsEquality(self, var, abs_var)

    def IndexOfConstraint(self, vars: "std::vector< operations_research::IntVar * > const &", index: "IntVar", target: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IndexOfConstraint(self, vars, index, target)

    def ConstraintInitialPropagateCallback(self, ct: "Constraint") -> "operations_research::Demon *":
        return _pywrapcp.Solver_ConstraintInitialPropagateCallback(self, ct)

    def DelayedConstraintInitialPropagateCallback(self, ct: "Constraint") -> "operations_research::Demon *":
        return _pywrapcp.Solver_DelayedConstraintInitialPropagateCallback(self, ct)

    def ClosureDemon(self, closure: "operations_research::Solver::Closure") -> "operations_research::Demon *":
        return _pywrapcp.Solver_ClosureDemon(self, closure)

    def BetweenCt(self, expr: "IntExpr", l: "int64", u: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_BetweenCt(self, expr, l, u)

    def IsBetweenCt(self, expr: "IntExpr", l: "int64", u: "int64", b: "IntVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsBetweenCt(self, expr, l, u, b)

    def IsBetweenVar(self, v: "IntExpr", l: "int64", u: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsBetweenVar(self, v, l, u)

    def MemberCt(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_MemberCt(self, *args)

    def NotMemberCt(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_NotMemberCt(self, *args)

    def IsMemberCt(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_IsMemberCt(self, *args)

    def IsMemberVar(self, *args) -> "operations_research::IntVar *":
        return _pywrapcp.Solver_IsMemberVar(self, *args)

    def Count(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_Count(self, *args)

    def Distribute(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_Distribute(self, *args)

    def Deviation(self, vars: "std::vector< operations_research::IntVar * > const &", deviation_var: "IntVar", total_sum: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_Deviation(self, vars, deviation_var, total_sum)

    def AllDifferent(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_AllDifferent(self, *args)

    def AllDifferentExcept(self, vars: "std::vector< operations_research::IntVar * > const &", escape_value: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_AllDifferentExcept(self, vars, escape_value)

    def SortingConstraint(self, vars: "std::vector< operations_research::IntVar * > const &", sorted: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_SortingConstraint(self, vars, sorted)

    def LexicalLess(self, left: "std::vector< operations_research::IntVar * > const &", right: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_LexicalLess(self, left, right)

    def LexicalLessOrEqual(self, left: "std::vector< operations_research::IntVar * > const &", right: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_LexicalLessOrEqual(self, left, right)

    def InversePermutationConstraint(self, left: "std::vector< operations_research::IntVar * > const &", right: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_InversePermutationConstraint(self, left, right)

    def NullIntersect(self, first_vars: "std::vector< operations_research::IntVar * > const &", second_vars: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_NullIntersect(self, first_vars, second_vars)

    def NullIntersectExcept(self, first_vars: "std::vector< operations_research::IntVar * > const &", second_vars: "std::vector< operations_research::IntVar * > const &", escape_value: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_NullIntersectExcept(self, first_vars, second_vars, escape_value)

    def Circuit(self, nexts: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_Circuit(self, nexts)

    def SubCircuit(self, nexts: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_SubCircuit(self, nexts)

    def DelayedPathCumul(self, nexts: "std::vector< operations_research::IntVar * > const &", active: "std::vector< operations_research::IntVar * > const &", cumuls: "std::vector< operations_research::IntVar * > const &", transits: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_DelayedPathCumul(self, nexts, active, cumuls, transits)

    def PathCumul(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_PathCumul(self, *args)

    def AllowedAssignments(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_AllowedAssignments(self, *args)

    def TransitionConstraint(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_TransitionConstraint(self, *args)

    def NonOverlappingBoxesConstraint(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_NonOverlappingBoxesConstraint(self, *args)

    def Pack(self, vars: "std::vector< operations_research::IntVar * > const &", number_of_bins: "int") -> "operations_research::Pack *":
        return _pywrapcp.Solver_Pack(self, vars, number_of_bins)

    def FixedDurationIntervalVar(self, *args) -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_FixedDurationIntervalVar(self, *args)

    def FixedInterval(self, start: "int64", duration: "int64", name: "std::string const &") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_FixedInterval(self, start, duration, name)

    def IntervalVar(self, start_min: "int64", start_max: "int64", duration_min: "int64", duration_max: "int64", end_min: "int64", end_max: "int64", optional: "bool", name: "std::string const &") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_IntervalVar(self, start_min, start_max, duration_min, duration_max, end_min, end_max, optional, name)

    def MirrorInterval(self, interval_var: "IntervalVar") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_MirrorInterval(self, interval_var)

    def FixedDurationStartSyncedOnStartIntervalVar(self, interval_var: "IntervalVar", duration: "int64", offset: "int64") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_FixedDurationStartSyncedOnStartIntervalVar(self, interval_var, duration, offset)

    def FixedDurationStartSyncedOnEndIntervalVar(self, interval_var: "IntervalVar", duration: "int64", offset: "int64") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_FixedDurationStartSyncedOnEndIntervalVar(self, interval_var, duration, offset)

    def FixedDurationEndSyncedOnStartIntervalVar(self, interval_var: "IntervalVar", duration: "int64", offset: "int64") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_FixedDurationEndSyncedOnStartIntervalVar(self, interval_var, duration, offset)

    def FixedDurationEndSyncedOnEndIntervalVar(self, interval_var: "IntervalVar", duration: "int64", offset: "int64") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_FixedDurationEndSyncedOnEndIntervalVar(self, interval_var, duration, offset)

    def IntervalRelaxedMin(self, interval_var: "IntervalVar") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_IntervalRelaxedMin(self, interval_var)

    def IntervalRelaxedMax(self, interval_var: "IntervalVar") -> "operations_research::IntervalVar *":
        return _pywrapcp.Solver_IntervalRelaxedMax(self, interval_var)

    def TemporalDisjunction(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_TemporalDisjunction(self, *args)

    def DisjunctiveConstraint(self, intervals: "std::vector< operations_research::IntervalVar * > const &", name: "std::string const &") -> "operations_research::DisjunctiveConstraint *":
        return _pywrapcp.Solver_DisjunctiveConstraint(self, intervals, name)

    def Cumulative(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_Cumulative(self, *args)

    def Cover(self, vars: "std::vector< operations_research::IntervalVar * > const &", target_var: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.Solver_Cover(self, vars, target_var)

    def Assignment(self, *args) -> "operations_research::Assignment *":
        return _pywrapcp.Solver_Assignment(self, *args)

    def FirstSolutionCollector(self, *args) -> "operations_research::SolutionCollector *":
        return _pywrapcp.Solver_FirstSolutionCollector(self, *args)

    def LastSolutionCollector(self, *args) -> "operations_research::SolutionCollector *":
        return _pywrapcp.Solver_LastSolutionCollector(self, *args)

    def BestValueSolutionCollector(self, *args) -> "operations_research::SolutionCollector *":
        return _pywrapcp.Solver_BestValueSolutionCollector(self, *args)

    def AllSolutionCollector(self, *args) -> "operations_research::SolutionCollector *":
        return _pywrapcp.Solver_AllSolutionCollector(self, *args)

    def Minimize(self, v: "IntVar", step: "int64") -> "operations_research::OptimizeVar *":
        return _pywrapcp.Solver_Minimize(self, v, step)

    def Maximize(self, v: "IntVar", step: "int64") -> "operations_research::OptimizeVar *":
        return _pywrapcp.Solver_Maximize(self, v, step)

    def Optimize(self, maximize: "bool", v: "IntVar", step: "int64") -> "operations_research::OptimizeVar *":
        return _pywrapcp.Solver_Optimize(self, maximize, v, step)

    def WeightedMinimize(self, *args) -> "operations_research::OptimizeVar *":
        return _pywrapcp.Solver_WeightedMinimize(self, *args)

    def WeightedMaximize(self, *args) -> "operations_research::OptimizeVar *":
        return _pywrapcp.Solver_WeightedMaximize(self, *args)

    def WeightedOptimize(self, *args) -> "operations_research::OptimizeVar *":
        return _pywrapcp.Solver_WeightedOptimize(self, *args)

    def TabuSearch(self, maximize: "bool", v: "IntVar", step: "int64", vars: "std::vector< operations_research::IntVar * > const &", keep_tenure: "int64", forbid_tenure: "int64", tabu_factor: "double") -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_TabuSearch(self, maximize, v, step, vars, keep_tenure, forbid_tenure, tabu_factor)

    def SimulatedAnnealing(self, maximize: "bool", v: "IntVar", step: "int64", initial_temperature: "int64") -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_SimulatedAnnealing(self, maximize, v, step, initial_temperature)

    def LubyRestart(self, scale_factor: "int") -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_LubyRestart(self, scale_factor)

    def ConstantRestart(self, frequency: "int") -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_ConstantRestart(self, frequency)

    def TimeLimit(self, time_in_ms: "int64") -> "operations_research::RegularLimit *":
        return _pywrapcp.Solver_TimeLimit(self, time_in_ms)

    def BranchesLimit(self, branches: "int64") -> "operations_research::RegularLimit *":
        return _pywrapcp.Solver_BranchesLimit(self, branches)

    def FailuresLimit(self, failures: "int64") -> "operations_research::RegularLimit *":
        return _pywrapcp.Solver_FailuresLimit(self, failures)

    def SolutionsLimit(self, solutions: "int64") -> "operations_research::RegularLimit *":
        return _pywrapcp.Solver_SolutionsLimit(self, solutions)

    def Limit(self, *args) -> "operations_research::SearchLimit *":
        return _pywrapcp.Solver_Limit(self, *args)

    def CustomLimit(self, limiter: "std::function< bool () >") -> "operations_research::SearchLimit *":
        return _pywrapcp.Solver_CustomLimit(self, limiter)

    def SearchLog(self, *args) -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_SearchLog(self, *args)

    def SearchTrace(self, prefix: "std::string const &") -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_SearchTrace(self, prefix)

    def PrintModelVisitor(self) -> "operations_research::ModelVisitor *":
        return _pywrapcp.Solver_PrintModelVisitor(self)

    def StatisticsModelVisitor(self) -> "operations_research::ModelVisitor *":
        return _pywrapcp.Solver_StatisticsModelVisitor(self)

    def AssignVariableValue(self, var: "IntVar", val: "int64") -> "operations_research::Decision *":
        return _pywrapcp.Solver_AssignVariableValue(self, var, val)

    def VariableLessOrEqualValue(self, var: "IntVar", value: "int64") -> "operations_research::Decision *":
        return _pywrapcp.Solver_VariableLessOrEqualValue(self, var, value)

    def VariableGreaterOrEqualValue(self, var: "IntVar", value: "int64") -> "operations_research::Decision *":
        return _pywrapcp.Solver_VariableGreaterOrEqualValue(self, var, value)

    def SplitVariableDomain(self, var: "IntVar", val: "int64", start_with_lower_half: "bool") -> "operations_research::Decision *":
        return _pywrapcp.Solver_SplitVariableDomain(self, var, val, start_with_lower_half)

    def AssignVariableValueOrFail(self, var: "IntVar", value: "int64") -> "operations_research::Decision *":
        return _pywrapcp.Solver_AssignVariableValueOrFail(self, var, value)

    def AssignVariablesValues(self, vars: "std::vector< operations_research::IntVar * > const &", values: "std::vector< int64 > const &") -> "operations_research::Decision *":
        return _pywrapcp.Solver_AssignVariablesValues(self, vars, values)

    def FailDecision(self) -> "operations_research::Decision *":
        return _pywrapcp.Solver_FailDecision(self)

    def Decision(self, apply: "operations_research::Solver::Action", refute: "operations_research::Solver::Action") -> "operations_research::Decision *":
        return _pywrapcp.Solver_Decision(self, apply, refute)

    def Compose(self, dbs: "std::vector< operations_research::DecisionBuilder * > const &") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_Compose(self, dbs)

    def Try(self, dbs: "std::vector< operations_research::DecisionBuilder * > const &") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_Try(self, dbs)

    def DefaultPhase(self, *args) -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_DefaultPhase(self, *args)

    def ScheduleOrPostpone(self, var: "IntervalVar", est: "int64", marker: "int64 *const") -> "operations_research::Decision *":
        return _pywrapcp.Solver_ScheduleOrPostpone(self, var, est, marker)

    def ScheduleOrExpedite(self, var: "IntervalVar", est: "int64", marker: "int64 *const") -> "operations_research::Decision *":
        return _pywrapcp.Solver_ScheduleOrExpedite(self, var, est, marker)

    def RankFirstInterval(self, sequence: "SequenceVar", index: "int") -> "operations_research::Decision *":
        return _pywrapcp.Solver_RankFirstInterval(self, sequence, index)

    def RankLastInterval(self, sequence: "SequenceVar", index: "int") -> "operations_research::Decision *":
        return _pywrapcp.Solver_RankLastInterval(self, sequence, index)

    def Phase(self, *args) -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_Phase(self, *args)

    def DecisionBuilderFromAssignment(self, assignment: "Assignment", db: "DecisionBuilder", vars: "std::vector< operations_research::IntVar * > const &") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_DecisionBuilderFromAssignment(self, assignment, db, vars)

    def ConstraintAdder(self, ct: "Constraint") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_ConstraintAdder(self, ct)

    def SolveOnce(self, db: "DecisionBuilder", monitors: "std::vector< operations_research::SearchMonitor * > const &") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_SolveOnce(self, db, monitors)

    def NestedOptimize(self, *args) -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_NestedOptimize(self, *args)

    def RestoreAssignment(self, assignment: "Assignment") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_RestoreAssignment(self, assignment)

    def StoreAssignment(self, assignment: "Assignment") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_StoreAssignment(self, assignment)

    def Operator(self, *args) -> "operations_research::LocalSearchOperator *":
        return _pywrapcp.Solver_Operator(self, *args)

    def RandomLnsOperator(self, *args) -> "operations_research::LocalSearchOperator *":
        return _pywrapcp.Solver_RandomLnsOperator(self, *args)

    def MoveTowardTargetOperator(self, *args) -> "operations_research::LocalSearchOperator *":
        return _pywrapcp.Solver_MoveTowardTargetOperator(self, *args)

    def ConcatenateOperators(self, *args) -> "operations_research::LocalSearchOperator *":
        return _pywrapcp.Solver_ConcatenateOperators(self, *args)

    def RandomConcatenateOperators(self, *args) -> "operations_research::LocalSearchOperator *":
        return _pywrapcp.Solver_RandomConcatenateOperators(self, *args)

    def NeighborhoodLimit(self, op: "LocalSearchOperator", limit: "int64") -> "operations_research::LocalSearchOperator *":
        return _pywrapcp.Solver_NeighborhoodLimit(self, op, limit)

    def LocalSearchPhase(self, *args) -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_LocalSearchPhase(self, *args)

    def LocalSearchPhaseParameters(self, *args) -> "operations_research::LocalSearchPhaseParameters *":
        return _pywrapcp.Solver_LocalSearchPhaseParameters(self, *args)

    def SearchDepth(self) -> "int":
        return _pywrapcp.Solver_SearchDepth(self)

    def SearchLeftDepth(self) -> "int":
        return _pywrapcp.Solver_SearchLeftDepth(self)

    def SolveDepth(self) -> "int":
        return _pywrapcp.Solver_SolveDepth(self)

    def Rand64(self, size: "int64") -> "int64":
        return _pywrapcp.Solver_Rand64(self, size)

    def Rand32(self, size: "int32") -> "int32":
        return _pywrapcp.Solver_Rand32(self, size)

    def ReSeed(self, seed: "int32") -> "void":
        return _pywrapcp.Solver_ReSeed(self, seed)

    def LocalSearchProfile(self) -> "std::string":
        return _pywrapcp.Solver_LocalSearchProfile(self)

    def Constraints(self) -> "int":
        return _pywrapcp.Solver_Constraints(self)

    def Accept(self, visitor: "operations_research::ModelVisitor *const") -> "void":
        return _pywrapcp.Solver_Accept(self, visitor)

    def FinishCurrentSearch(self) -> "void":
        return _pywrapcp.Solver_FinishCurrentSearch(self)

    def RestartCurrentSearch(self) -> "void":
        return _pywrapcp.Solver_RestartCurrentSearch(self)

    def ShouldFail(self) -> "void":
        return _pywrapcp.Solver_ShouldFail(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.Solver___str__(self)

    def Add(self, ct):
      if isinstance(ct, PyConstraint):
        self.__python_constraints.append(ct)
      self.AddConstraint(ct)


    def TreeNoCycle(self, nexts: "std::vector< operations_research::IntVar * > const &", active: "std::vector< operations_research::IntVar * > const &", callback: "operations_research::Solver::IndexFilter1"=0) -> "operations_research::Constraint *":
        return _pywrapcp.Solver_TreeNoCycle(self, nexts, active, callback)

    def SearchLogWithCallback(self, period: "int", callback: "std::function< std::string () >") -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_SearchLogWithCallback(self, period, callback)

    def ElementFunction(self, values: "std::function< int64 (int64) >", index: "IntVar") -> "operations_research::IntExpr *":
        return _pywrapcp.Solver_ElementFunction(self, values, index)

    def VarEvalValStrPhase(self, vars: "std::vector< operations_research::IntVar * > const &", var_evaluator: "std::function< int64 (int64) >", val_str: "operations_research::Solver::IntValueStrategy") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_VarEvalValStrPhase(self, vars, var_evaluator, val_str)

    def VarStrValEvalPhase(self, vars: "std::vector< operations_research::IntVar * > const &", var_str: "operations_research::Solver::IntVarStrategy", val_eval: "operations_research::Solver::IndexEvaluator2") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_VarStrValEvalPhase(self, vars, var_str, val_eval)

    def VarEvalValEvalPhase(self, vars: "std::vector< operations_research::IntVar * > const &", var_eval: "std::function< int64 (int64) >", val_eval: "operations_research::Solver::IndexEvaluator2") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_VarEvalValEvalPhase(self, vars, var_eval, val_eval)

    def VarStrValEvalTieBreakPhase(self, vars: "std::vector< operations_research::IntVar * > const &", var_str: "operations_research::Solver::IntVarStrategy", val_eval: "operations_research::Solver::IndexEvaluator2", tie_breaker: "std::function< int64 (int64) >") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_VarStrValEvalTieBreakPhase(self, vars, var_str, val_eval, tie_breaker)

    def VarEvalValEvalTieBreakPhase(self, vars: "std::vector< operations_research::IntVar * > const &", var_eval: "std::function< int64 (int64) >", val_eval: "operations_research::Solver::IndexEvaluator2", tie_breaker: "std::function< int64 (int64) >") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_VarEvalValEvalTieBreakPhase(self, vars, var_eval, val_eval, tie_breaker)

    def EvalEvalStrPhase(self, vars: "std::vector< operations_research::IntVar * > const &", evaluator: "operations_research::Solver::IndexEvaluator2", str: "operations_research::Solver::EvaluatorStrategy") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_EvalEvalStrPhase(self, vars, evaluator, str)

    def EvalEvalStrTieBreakPhase(self, vars: "std::vector< operations_research::IntVar * > const &", evaluator: "operations_research::Solver::IndexEvaluator2", tie_breaker: "operations_research::Solver::IndexEvaluator1", str: "operations_research::Solver::EvaluatorStrategy") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.Solver_EvalEvalStrTieBreakPhase(self, vars, evaluator, tie_breaker, str)

    def GuidedLocalSearch(self, *args) -> "operations_research::SearchMonitor *":
        return _pywrapcp.Solver_GuidedLocalSearch(self, *args)

    def SumObjectiveFilter(self, vars: "std::vector< operations_research::IntVar * > const &", values: "operations_research::Solver::IndexEvaluator2", filter_enum: "operations_research::Solver::LocalSearchFilterBound") -> "operations_research::LocalSearchFilter *":
        return _pywrapcp.Solver_SumObjectiveFilter(self, vars, values, filter_enum)

# Register Solver in _pywrapcp:
_pywrapcp.Solver_swigregister(Solver)

def Solver_DefaultSolverParameters() -> "operations_research::ConstraintSolverParameters":
    return _pywrapcp.Solver_DefaultSolverParameters()

def Solver_MemoryUsage() -> "int64":
    return _pywrapcp.Solver_MemoryUsage()

class BaseObject(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        if self.__class__ == BaseObject:
            _self = None
        else:
            _self = self
        _pywrapcp.BaseObject_swiginit(self, _pywrapcp.new_BaseObject(_self, ))
    __swig_destroy__ = _pywrapcp.delete_BaseObject

    def DebugString(self) -> "std::string":
        return _pywrapcp.BaseObject_DebugString(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.BaseObject___str__(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.BaseObject___repr__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseObject(self)
        return weakref.proxy(self)

# Register BaseObject in _pywrapcp:
_pywrapcp.BaseObject_swigregister(BaseObject)

class PropagationBaseObject(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, s: "Solver"):
        if self.__class__ == PropagationBaseObject:
            _self = None
        else:
            _self = self
        _pywrapcp.PropagationBaseObject_swiginit(self, _pywrapcp.new_PropagationBaseObject(_self, s))
    __swig_destroy__ = _pywrapcp.delete_PropagationBaseObject

    def DebugString(self) -> "std::string":
        return _pywrapcp.PropagationBaseObject_DebugString(self)

    def solver(self) -> "operations_research::Solver *":
        return _pywrapcp.PropagationBaseObject_solver(self)

    def Name(self) -> "std::string":
        return _pywrapcp.PropagationBaseObject_Name(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_PropagationBaseObject(self)
        return weakref.proxy(self)

# Register PropagationBaseObject in _pywrapcp:
_pywrapcp.PropagationBaseObject_swigregister(PropagationBaseObject)

class Decision(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        if self.__class__ == Decision:
            _self = None
        else:
            _self = self
        _pywrapcp.Decision_swiginit(self, _pywrapcp.new_Decision(_self, ))
    __swig_destroy__ = _pywrapcp.delete_Decision

    def ApplyWrapper(self, s: "Solver") -> "void":
        return _pywrapcp.Decision_ApplyWrapper(self, s)

    def RefuteWrapper(self, s: "Solver") -> "void":
        return _pywrapcp.Decision_RefuteWrapper(self, s)

    def DebugString(self) -> "std::string":
        return _pywrapcp.Decision_DebugString(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.Decision___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.Decision___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Decision(self)
        return weakref.proxy(self)

# Register Decision in _pywrapcp:
_pywrapcp.Decision_swigregister(Decision)

class DecisionBuilder(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        if self.__class__ == DecisionBuilder:
            _self = None
        else:
            _self = self
        _pywrapcp.DecisionBuilder_swiginit(self, _pywrapcp.new_DecisionBuilder(_self, ))
    __swig_destroy__ = _pywrapcp.delete_DecisionBuilder

    def NextWrapper(self, s: "Solver") -> "operations_research::Decision *":
        return _pywrapcp.DecisionBuilder_NextWrapper(self, s)

    def DebugString(self) -> "std::string":
        return _pywrapcp.DecisionBuilder_DebugString(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.DecisionBuilder___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.DecisionBuilder___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_DecisionBuilder(self)
        return weakref.proxy(self)

# Register DecisionBuilder in _pywrapcp:
_pywrapcp.DecisionBuilder_swigregister(DecisionBuilder)

class Demon(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == Demon:
            _self = None
        else:
            _self = self
        _pywrapcp.Demon_swiginit(self, _pywrapcp.new_Demon(_self, ))
    __swig_destroy__ = _pywrapcp.delete_Demon

    def RunWrapper(self, s: "Solver") -> "void":
        return _pywrapcp.Demon_RunWrapper(self, s)

    def Priority(self) -> "operations_research::Solver::DemonPriority":
        return _pywrapcp.Demon_Priority(self)

    def DebugString(self) -> "std::string":
        return _pywrapcp.Demon_DebugString(self)

    def Inhibit(self, s: "Solver") -> "void":
        return _pywrapcp.Demon_Inhibit(self, s)

    def Desinhibit(self, s: "Solver") -> "void":
        return _pywrapcp.Demon_Desinhibit(self, s)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Demon(self)
        return weakref.proxy(self)

# Register Demon in _pywrapcp:
_pywrapcp.Demon_swigregister(Demon)

class Constraint(PropagationBaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, solver: "Solver"):
        if self.__class__ == Constraint:
            _self = None
        else:
            _self = self
        _pywrapcp.Constraint_swiginit(self, _pywrapcp.new_Constraint(_self, solver))
    __swig_destroy__ = _pywrapcp.delete_Constraint

    def Post(self) -> "void":
        return _pywrapcp.Constraint_Post(self)

    def InitialPropagateWrapper(self) -> "void":
        return _pywrapcp.Constraint_InitialPropagateWrapper(self)

    def DebugString(self) -> "std::string":
        return _pywrapcp.Constraint_DebugString(self)

    def Var(self) -> "operations_research::IntVar *":
        return _pywrapcp.Constraint_Var(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.Constraint___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.Constraint___str__(self)

    def __add__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___add__(self, *args)

    def __radd__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___radd__(self, v)

    def __sub__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___sub__(self, *args)

    def __rsub__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___rsub__(self, v)

    def __mul__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___mul__(self, *args)

    def __rmul__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___rmul__(self, v)

    def __floordiv__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___floordiv__(self, v)

    def __neg__(self) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___neg__(self)

    def __abs__(self) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint___abs__(self)

    def Square(self) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint_Square(self)

    def __eq__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Constraint___eq__(self, *args)

    def __ne__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Constraint___ne__(self, *args)

    def __ge__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Constraint___ge__(self, *args)

    def __gt__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Constraint___gt__(self, *args)

    def __le__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Constraint___le__(self, *args)

    def __lt__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.Constraint___lt__(self, *args)

    def MapTo(self, vars: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.Constraint_MapTo(self, vars)

    def IndexOf(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.Constraint_IndexOf(self, *args)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Constraint(self)
        return weakref.proxy(self)

# Register Constraint in _pywrapcp:
_pywrapcp.Constraint_swigregister(Constraint)

class SearchMonitor(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, s: "Solver"):
        if self.__class__ == SearchMonitor:
            _self = None
        else:
            _self = self
        _pywrapcp.SearchMonitor_swiginit(self, _pywrapcp.new_SearchMonitor(_self, s))
    __swig_destroy__ = _pywrapcp.delete_SearchMonitor

    def EnterSearch(self) -> "void":
        return _pywrapcp.SearchMonitor_EnterSearch(self)

    def RestartSearch(self) -> "void":
        return _pywrapcp.SearchMonitor_RestartSearch(self)

    def ExitSearch(self) -> "void":
        return _pywrapcp.SearchMonitor_ExitSearch(self)

    def BeginNextDecision(self, b: "DecisionBuilder") -> "void":
        return _pywrapcp.SearchMonitor_BeginNextDecision(self, b)

    def EndNextDecision(self, b: "DecisionBuilder", d: "Decision") -> "void":
        return _pywrapcp.SearchMonitor_EndNextDecision(self, b, d)

    def ApplyDecision(self, d: "Decision") -> "void":
        return _pywrapcp.SearchMonitor_ApplyDecision(self, d)

    def RefuteDecision(self, d: "Decision") -> "void":
        return _pywrapcp.SearchMonitor_RefuteDecision(self, d)

    def AfterDecision(self, d: "Decision", apply: "bool") -> "void":
        return _pywrapcp.SearchMonitor_AfterDecision(self, d, apply)

    def BeginFail(self) -> "void":
        return _pywrapcp.SearchMonitor_BeginFail(self)

    def EndFail(self) -> "void":
        return _pywrapcp.SearchMonitor_EndFail(self)

    def BeginInitialPropagation(self) -> "void":
        return _pywrapcp.SearchMonitor_BeginInitialPropagation(self)

    def EndInitialPropagation(self) -> "void":
        return _pywrapcp.SearchMonitor_EndInitialPropagation(self)

    def AcceptSolution(self) -> "bool":
        return _pywrapcp.SearchMonitor_AcceptSolution(self)

    def AtSolution(self) -> "bool":
        return _pywrapcp.SearchMonitor_AtSolution(self)

    def NoMoreSolutions(self) -> "void":
        return _pywrapcp.SearchMonitor_NoMoreSolutions(self)

    def LocalOptimum(self) -> "bool":
        return _pywrapcp.SearchMonitor_LocalOptimum(self)

    def AcceptDelta(self, delta: "Assignment", deltadelta: "Assignment") -> "bool":
        return _pywrapcp.SearchMonitor_AcceptDelta(self, delta, deltadelta)

    def AcceptNeighbor(self) -> "void":
        return _pywrapcp.SearchMonitor_AcceptNeighbor(self)

    def solver(self) -> "operations_research::Solver *":
        return _pywrapcp.SearchMonitor_solver(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.SearchMonitor___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.SearchMonitor___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_SearchMonitor(self)
        return weakref.proxy(self)

# Register SearchMonitor in _pywrapcp:
_pywrapcp.SearchMonitor_swigregister(SearchMonitor)

class IntExpr(PropagationBaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def Min(self) -> "int64":
        return _pywrapcp.IntExpr_Min(self)

    def SetMin(self, m: "int64") -> "void":
        return _pywrapcp.IntExpr_SetMin(self, m)

    def Max(self) -> "int64":
        return _pywrapcp.IntExpr_Max(self)

    def SetMax(self, m: "int64") -> "void":
        return _pywrapcp.IntExpr_SetMax(self, m)

    def SetRange(self, l: "int64", u: "int64") -> "void":
        return _pywrapcp.IntExpr_SetRange(self, l, u)

    def SetValue(self, v: "int64") -> "void":
        return _pywrapcp.IntExpr_SetValue(self, v)

    def Bound(self) -> "bool":
        return _pywrapcp.IntExpr_Bound(self)

    def IsVar(self) -> "bool":
        return _pywrapcp.IntExpr_IsVar(self)

    def Var(self) -> "operations_research::IntVar *":
        return _pywrapcp.IntExpr_Var(self)

    def VarWithName(self, name: "std::string const &") -> "operations_research::IntVar *":
        return _pywrapcp.IntExpr_VarWithName(self, name)

    def WhenRange(self, *args) -> "void":
        return _pywrapcp.IntExpr_WhenRange(self, *args)

    def __repr__(self) -> "std::string":
        return _pywrapcp.IntExpr___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.IntExpr___str__(self)

    def __add__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___add__(self, *args)

    def __radd__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___radd__(self, v)

    def __sub__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___sub__(self, *args)

    def __rsub__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___rsub__(self, v)

    def __mul__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___mul__(self, *args)

    def __rmul__(self, v: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___rmul__(self, v)

    def __floordiv__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___floordiv__(self, *args)

    def __mod__(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___mod__(self, *args)

    def __neg__(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___neg__(self)

    def __abs__(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr___abs__(self)

    def Square(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr_Square(self)

    def __eq__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr___eq__(self, *args)

    def __ne__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr___ne__(self, *args)

    def __ge__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr___ge__(self, *args)

    def __gt__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr___gt__(self, *args)

    def __le__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr___le__(self, *args)

    def __lt__(self, *args) -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr___lt__(self, *args)

    def MapTo(self, vars: "std::vector< operations_research::IntVar * > const &") -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr_MapTo(self, vars)

    def IndexOf(self, *args) -> "operations_research::IntExpr *":
        return _pywrapcp.IntExpr_IndexOf(self, *args)

    def IsMember(self, values: "std::vector< int64 > const &") -> "operations_research::IntVar *":
        return _pywrapcp.IntExpr_IsMember(self, values)

    def Member(self, values: "std::vector< int64 > const &") -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr_Member(self, values)

    def NotMember(self, starts: "std::vector< int64 > const &", ends: "std::vector< int64 > const &") -> "operations_research::Constraint *":
        return _pywrapcp.IntExpr_NotMember(self, starts, ends)

# Register IntExpr in _pywrapcp:
_pywrapcp.IntExpr_swigregister(IntExpr)

class IntVarIterator(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Init(self) -> "void":
        return _pywrapcp.IntVarIterator_Init(self)

    def Ok(self) -> "bool":
        return _pywrapcp.IntVarIterator_Ok(self)

    def Value(self) -> "int64":
        return _pywrapcp.IntVarIterator_Value(self)

    def Next(self) -> "void":
        return _pywrapcp.IntVarIterator_Next(self)

    def DebugString(self) -> "std::string":
        return _pywrapcp.IntVarIterator_DebugString(self)

    def __iter__(self):
      self.Init()
      return self

    def next(self):
      if self.Ok():
        result = self.Value()
        self.Next()
        return result
      else:
        raise StopIteration()

    def __next__(self):
      return self.next()


# Register IntVarIterator in _pywrapcp:
_pywrapcp.IntVarIterator_swigregister(IntVarIterator)

class IntVar(IntExpr):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def IsVar(self) -> "bool":
        return _pywrapcp.IntVar_IsVar(self)

    def Var(self) -> "operations_research::IntVar *":
        return _pywrapcp.IntVar_Var(self)

    def Value(self) -> "int64":
        return _pywrapcp.IntVar_Value(self)

    def RemoveValue(self, v: "int64") -> "void":
        return _pywrapcp.IntVar_RemoveValue(self, v)

    def RemoveInterval(self, l: "int64", u: "int64") -> "void":
        return _pywrapcp.IntVar_RemoveInterval(self, l, u)

    def RemoveValues(self, values: "std::vector< int64 > const &") -> "void":
        return _pywrapcp.IntVar_RemoveValues(self, values)

    def SetValues(self, values: "std::vector< int64 > const &") -> "void":
        return _pywrapcp.IntVar_SetValues(self, values)

    def WhenBound(self, *args) -> "void":
        return _pywrapcp.IntVar_WhenBound(self, *args)

    def WhenDomain(self, *args) -> "void":
        return _pywrapcp.IntVar_WhenDomain(self, *args)

    def Size(self) -> "uint64":
        return _pywrapcp.IntVar_Size(self)

    def Contains(self, v: "int64") -> "bool":
        return _pywrapcp.IntVar_Contains(self, v)

    def HoleIteratorAux(self, reversible: "bool") -> "operations_research::IntVarIterator *":
        return _pywrapcp.IntVar_HoleIteratorAux(self, reversible)

    def DomainIteratorAux(self, reversible: "bool") -> "operations_research::IntVarIterator *":
        return _pywrapcp.IntVar_DomainIteratorAux(self, reversible)

    def OldMin(self) -> "int64":
        return _pywrapcp.IntVar_OldMin(self)

    def OldMax(self) -> "int64":
        return _pywrapcp.IntVar_OldMax(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.IntVar___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.IntVar___str__(self)

    def DomainIterator(self):
      return iter(self.DomainIteratorAux(False))

    def HoleIterator(self):
      return iter(self.HoleIteratorAux(False))


# Register IntVar in _pywrapcp:
_pywrapcp.IntVar_swigregister(IntVar)

class SolutionCollector(SearchMonitor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def DebugString(self) -> "std::string":
        return _pywrapcp.SolutionCollector_DebugString(self)

    def Add(self, *args) -> "void":
        return _pywrapcp.SolutionCollector_Add(self, *args)

    def AddObjective(self, objective: "IntVar") -> "void":
        return _pywrapcp.SolutionCollector_AddObjective(self, objective)

    def EnterSearch(self) -> "void":
        return _pywrapcp.SolutionCollector_EnterSearch(self)

    def SolutionCount(self) -> "int":
        return _pywrapcp.SolutionCollector_SolutionCount(self)

    def Solution(self, n: "int") -> "operations_research::Assignment *":
        return _pywrapcp.SolutionCollector_Solution(self, n)

    def WallTime(self, n: "int") -> "int64":
        return _pywrapcp.SolutionCollector_WallTime(self, n)

    def Branches(self, n: "int") -> "int64":
        return _pywrapcp.SolutionCollector_Branches(self, n)

    def Failures(self, n: "int") -> "int64":
        return _pywrapcp.SolutionCollector_Failures(self, n)

    def ObjectiveValue(self, n: "int") -> "int64":
        return _pywrapcp.SolutionCollector_ObjectiveValue(self, n)

    def Value(self, n: "int", var: "IntVar") -> "int64":
        return _pywrapcp.SolutionCollector_Value(self, n, var)

    def StartValue(self, n: "int", var: "IntervalVar") -> "int64":
        return _pywrapcp.SolutionCollector_StartValue(self, n, var)

    def EndValue(self, n: "int", var: "IntervalVar") -> "int64":
        return _pywrapcp.SolutionCollector_EndValue(self, n, var)

    def DurationValue(self, n: "int", var: "IntervalVar") -> "int64":
        return _pywrapcp.SolutionCollector_DurationValue(self, n, var)

    def PerformedValue(self, n: "int", var: "IntervalVar") -> "int64":
        return _pywrapcp.SolutionCollector_PerformedValue(self, n, var)

    def ForwardSequence(self, n: "int", var: "SequenceVar") -> "std::vector< int > const &":
        return _pywrapcp.SolutionCollector_ForwardSequence(self, n, var)

    def BackwardSequence(self, n: "int", var: "SequenceVar") -> "std::vector< int > const &":
        return _pywrapcp.SolutionCollector_BackwardSequence(self, n, var)

    def Unperformed(self, n: "int", var: "SequenceVar") -> "std::vector< int > const &":
        return _pywrapcp.SolutionCollector_Unperformed(self, n, var)

# Register SolutionCollector in _pywrapcp:
_pywrapcp.SolutionCollector_swigregister(SolutionCollector)

class OptimizeVar(SearchMonitor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Best(self) -> "int64":
        return _pywrapcp.OptimizeVar_Best(self)

    def Var(self) -> "operations_research::IntVar *":
        return _pywrapcp.OptimizeVar_Var(self)

    def AcceptDelta(self, delta: "Assignment", deltadelta: "Assignment") -> "bool":
        return _pywrapcp.OptimizeVar_AcceptDelta(self, delta, deltadelta)

    def EnterSearch(self) -> "void":
        return _pywrapcp.OptimizeVar_EnterSearch(self)

    def BeginNextDecision(self, db: "DecisionBuilder") -> "void":
        return _pywrapcp.OptimizeVar_BeginNextDecision(self, db)

    def RefuteDecision(self, d: "Decision") -> "void":
        return _pywrapcp.OptimizeVar_RefuteDecision(self, d)

    def AtSolution(self) -> "bool":
        return _pywrapcp.OptimizeVar_AtSolution(self)

    def AcceptSolution(self) -> "bool":
        return _pywrapcp.OptimizeVar_AcceptSolution(self)

    def DebugString(self) -> "std::string":
        return _pywrapcp.OptimizeVar_DebugString(self)

# Register OptimizeVar in _pywrapcp:
_pywrapcp.OptimizeVar_swigregister(OptimizeVar)

class SearchLimit(SearchMonitor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_SearchLimit

    def Crossed(self) -> "bool":
        return _pywrapcp.SearchLimit_Crossed(self)

    def Check(self) -> "bool":
        return _pywrapcp.SearchLimit_Check(self)

    def Init(self) -> "void":
        return _pywrapcp.SearchLimit_Init(self)

    def EnterSearch(self) -> "void":
        return _pywrapcp.SearchLimit_EnterSearch(self)

    def BeginNextDecision(self, b: "DecisionBuilder") -> "void":
        return _pywrapcp.SearchLimit_BeginNextDecision(self, b)

    def RefuteDecision(self, d: "Decision") -> "void":
        return _pywrapcp.SearchLimit_RefuteDecision(self, d)

    def DebugString(self) -> "std::string":
        return _pywrapcp.SearchLimit_DebugString(self)

# Register SearchLimit in _pywrapcp:
_pywrapcp.SearchLimit_swigregister(SearchLimit)

class IntervalVar(PropagationBaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")

    def StartMin(self) -> "int64":
        return _pywrapcp.IntervalVar_StartMin(self)

    def StartMax(self) -> "int64":
        return _pywrapcp.IntervalVar_StartMax(self)

    def SetStartMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetStartMin(self, m)

    def SetStartMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetStartMax(self, m)

    def SetStartRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetStartRange(self, mi, ma)

    def OldStartMin(self) -> "int64":
        return _pywrapcp.IntervalVar_OldStartMin(self)

    def OldStartMax(self) -> "int64":
        return _pywrapcp.IntervalVar_OldStartMax(self)

    def WhenStartRange(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenStartRange(self, *args)

    def WhenStartBound(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenStartBound(self, *args)

    def DurationMin(self) -> "int64":
        return _pywrapcp.IntervalVar_DurationMin(self)

    def DurationMax(self) -> "int64":
        return _pywrapcp.IntervalVar_DurationMax(self)

    def SetDurationMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetDurationMin(self, m)

    def SetDurationMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetDurationMax(self, m)

    def SetDurationRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetDurationRange(self, mi, ma)

    def OldDurationMin(self) -> "int64":
        return _pywrapcp.IntervalVar_OldDurationMin(self)

    def OldDurationMax(self) -> "int64":
        return _pywrapcp.IntervalVar_OldDurationMax(self)

    def WhenDurationRange(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenDurationRange(self, *args)

    def WhenDurationBound(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenDurationBound(self, *args)

    def EndMin(self) -> "int64":
        return _pywrapcp.IntervalVar_EndMin(self)

    def EndMax(self) -> "int64":
        return _pywrapcp.IntervalVar_EndMax(self)

    def SetEndMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetEndMin(self, m)

    def SetEndMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetEndMax(self, m)

    def SetEndRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVar_SetEndRange(self, mi, ma)

    def OldEndMin(self) -> "int64":
        return _pywrapcp.IntervalVar_OldEndMin(self)

    def OldEndMax(self) -> "int64":
        return _pywrapcp.IntervalVar_OldEndMax(self)

    def WhenEndRange(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenEndRange(self, *args)

    def WhenEndBound(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenEndBound(self, *args)

    def MustBePerformed(self) -> "bool":
        return _pywrapcp.IntervalVar_MustBePerformed(self)

    def MayBePerformed(self) -> "bool":
        return _pywrapcp.IntervalVar_MayBePerformed(self)

    def CannotBePerformed(self) -> "bool":
        return _pywrapcp.IntervalVar_CannotBePerformed(self)

    def IsPerformedBound(self) -> "bool":
        return _pywrapcp.IntervalVar_IsPerformedBound(self)

    def SetPerformed(self, val: "bool") -> "void":
        return _pywrapcp.IntervalVar_SetPerformed(self, val)

    def WasPerformedBound(self) -> "bool":
        return _pywrapcp.IntervalVar_WasPerformedBound(self)

    def WhenPerformedBound(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenPerformedBound(self, *args)

    def WhenAnything(self, *args) -> "void":
        return _pywrapcp.IntervalVar_WhenAnything(self, *args)

    def StartExpr(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_StartExpr(self)

    def DurationExpr(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_DurationExpr(self)

    def EndExpr(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_EndExpr(self)

    def PerformedExpr(self) -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_PerformedExpr(self)

    def SafeStartExpr(self, unperformed_value: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_SafeStartExpr(self, unperformed_value)

    def SafeDurationExpr(self, unperformed_value: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_SafeDurationExpr(self, unperformed_value)

    def SafeEndExpr(self, unperformed_value: "int64") -> "operations_research::IntExpr *":
        return _pywrapcp.IntervalVar_SafeEndExpr(self, unperformed_value)

    def EndsAfterEnd(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAfterEnd(self, other)

    def EndsAfterEndWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAfterEndWithDelay(self, other, delay)

    def EndsAfterStart(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAfterStart(self, other)

    def EndsAfterStartWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAfterStartWithDelay(self, other, delay)

    def EndsAtEnd(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAtEnd(self, other)

    def EndsAtEndWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAtEndWithDelay(self, other, delay)

    def EndsAtStart(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAtStart(self, other)

    def EndsAtStartWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAtStartWithDelay(self, other, delay)

    def StartsAfterEnd(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAfterEnd(self, other)

    def StartsAfterEndWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAfterEndWithDelay(self, other, delay)

    def StartsAfterStart(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAfterStart(self, other)

    def StartsAfterStartWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAfterStartWithDelay(self, other, delay)

    def StartsAtEnd(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAtEnd(self, other)

    def StartsAtEndWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAtEndWithDelay(self, other, delay)

    def StartsAtStart(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAtStart(self, other)

    def StartsAtStartWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAtStartWithDelay(self, other, delay)

    def StaysInSync(self, other: "IntervalVar") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StaysInSync(self, other)

    def StaysInSyncWithDelay(self, other: "IntervalVar", delay: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StaysInSyncWithDelay(self, other, delay)

    def EndsAfter(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAfter(self, date)

    def EndsAt(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsAt(self, date)

    def EndsBefore(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_EndsBefore(self, date)

    def StartsAfter(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAfter(self, date)

    def StartsAt(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsAt(self, date)

    def StartsBefore(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_StartsBefore(self, date)

    def CrossesDate(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_CrossesDate(self, date)

    def AvoidsDate(self, date: "int64") -> "operations_research::Constraint *":
        return _pywrapcp.IntervalVar_AvoidsDate(self, date)

    def __repr__(self) -> "std::string":
        return _pywrapcp.IntervalVar___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.IntervalVar___str__(self)

# Register IntervalVar in _pywrapcp:
_pywrapcp.IntervalVar_swigregister(IntervalVar)

class SequenceVar(PropagationBaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def DebugString(self) -> "std::string":
        return _pywrapcp.SequenceVar_DebugString(self)

    def RankFirst(self, index: "int") -> "void":
        return _pywrapcp.SequenceVar_RankFirst(self, index)

    def RankNotFirst(self, index: "int") -> "void":
        return _pywrapcp.SequenceVar_RankNotFirst(self, index)

    def RankLast(self, index: "int") -> "void":
        return _pywrapcp.SequenceVar_RankLast(self, index)

    def RankNotLast(self, index: "int") -> "void":
        return _pywrapcp.SequenceVar_RankNotLast(self, index)

    def Interval(self, index: "int") -> "operations_research::IntervalVar *":
        return _pywrapcp.SequenceVar_Interval(self, index)

    def Next(self, index: "int") -> "operations_research::IntVar *":
        return _pywrapcp.SequenceVar_Next(self, index)

    def Size(self) -> "int64":
        return _pywrapcp.SequenceVar_Size(self)

    def __repr__(self) -> "std::string":
        return _pywrapcp.SequenceVar___repr__(self)

    def __str__(self) -> "std::string":
        return _pywrapcp.SequenceVar___str__(self)

# Register SequenceVar in _pywrapcp:
_pywrapcp.SequenceVar_swigregister(SequenceVar)

class AssignmentElement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Activate(self) -> "void":
        return _pywrapcp.AssignmentElement_Activate(self)

    def Deactivate(self) -> "void":
        return _pywrapcp.AssignmentElement_Deactivate(self)

    def Activated(self) -> "bool":
        return _pywrapcp.AssignmentElement_Activated(self)
    __swig_destroy__ = _pywrapcp.delete_AssignmentElement

# Register AssignmentElement in _pywrapcp:
_pywrapcp.AssignmentElement_swigregister(AssignmentElement)

class IntVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Var(self) -> "operations_research::IntVar *":
        return _pywrapcp.IntVarElement_Var(self)

    def Min(self) -> "int64":
        return _pywrapcp.IntVarElement_Min(self)

    def SetMin(self, m: "int64") -> "void":
        return _pywrapcp.IntVarElement_SetMin(self, m)

    def Max(self) -> "int64":
        return _pywrapcp.IntVarElement_Max(self)

    def SetMax(self, m: "int64") -> "void":
        return _pywrapcp.IntVarElement_SetMax(self, m)

    def Value(self) -> "int64":
        return _pywrapcp.IntVarElement_Value(self)

    def Bound(self) -> "bool":
        return _pywrapcp.IntVarElement_Bound(self)

    def SetRange(self, l: "int64", u: "int64") -> "void":
        return _pywrapcp.IntVarElement_SetRange(self, l, u)

    def SetValue(self, v: "int64") -> "void":
        return _pywrapcp.IntVarElement_SetValue(self, v)

    def __eq__(self, element: "IntVarElement") -> "bool":
        return _pywrapcp.IntVarElement___eq__(self, element)

    def __ne__(self, element: "IntVarElement") -> "bool":
        return _pywrapcp.IntVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_IntVarElement

# Register IntVarElement in _pywrapcp:
_pywrapcp.IntVarElement_swigregister(IntVarElement)

class IntervalVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Var(self) -> "operations_research::IntervalVar *":
        return _pywrapcp.IntervalVarElement_Var(self)

    def StartMin(self) -> "int64":
        return _pywrapcp.IntervalVarElement_StartMin(self)

    def StartMax(self) -> "int64":
        return _pywrapcp.IntervalVarElement_StartMax(self)

    def StartValue(self) -> "int64":
        return _pywrapcp.IntervalVarElement_StartValue(self)

    def DurationMin(self) -> "int64":
        return _pywrapcp.IntervalVarElement_DurationMin(self)

    def DurationMax(self) -> "int64":
        return _pywrapcp.IntervalVarElement_DurationMax(self)

    def DurationValue(self) -> "int64":
        return _pywrapcp.IntervalVarElement_DurationValue(self)

    def EndMin(self) -> "int64":
        return _pywrapcp.IntervalVarElement_EndMin(self)

    def EndMax(self) -> "int64":
        return _pywrapcp.IntervalVarElement_EndMax(self)

    def EndValue(self) -> "int64":
        return _pywrapcp.IntervalVarElement_EndValue(self)

    def PerformedMin(self) -> "int64":
        return _pywrapcp.IntervalVarElement_PerformedMin(self)

    def PerformedMax(self) -> "int64":
        return _pywrapcp.IntervalVarElement_PerformedMax(self)

    def PerformedValue(self) -> "int64":
        return _pywrapcp.IntervalVarElement_PerformedValue(self)

    def SetStartMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetStartMin(self, m)

    def SetStartMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetStartMax(self, m)

    def SetStartRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetStartRange(self, mi, ma)

    def SetStartValue(self, v: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetStartValue(self, v)

    def SetDurationMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetDurationMin(self, m)

    def SetDurationMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetDurationMax(self, m)

    def SetDurationRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetDurationRange(self, mi, ma)

    def SetDurationValue(self, v: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetDurationValue(self, v)

    def SetEndMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetEndMin(self, m)

    def SetEndMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetEndMax(self, m)

    def SetEndRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetEndRange(self, mi, ma)

    def SetEndValue(self, v: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetEndValue(self, v)

    def SetPerformedMin(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetPerformedMin(self, m)

    def SetPerformedMax(self, m: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetPerformedMax(self, m)

    def SetPerformedRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetPerformedRange(self, mi, ma)

    def SetPerformedValue(self, v: "int64") -> "void":
        return _pywrapcp.IntervalVarElement_SetPerformedValue(self, v)

    def __eq__(self, element: "IntervalVarElement") -> "bool":
        return _pywrapcp.IntervalVarElement___eq__(self, element)

    def __ne__(self, element: "IntervalVarElement") -> "bool":
        return _pywrapcp.IntervalVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarElement

# Register IntervalVarElement in _pywrapcp:
_pywrapcp.IntervalVarElement_swigregister(IntervalVarElement)

class SequenceVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Var(self) -> "operations_research::SequenceVar *":
        return _pywrapcp.SequenceVarElement_Var(self)

    def ForwardSequence(self) -> "std::vector< int > const &":
        return _pywrapcp.SequenceVarElement_ForwardSequence(self)

    def BackwardSequence(self) -> "std::vector< int > const &":
        return _pywrapcp.SequenceVarElement_BackwardSequence(self)

    def Unperformed(self) -> "std::vector< int > const &":
        return _pywrapcp.SequenceVarElement_Unperformed(self)

    def SetSequence(self, forward_sequence: "std::vector< int > const &", backward_sequence: "std::vector< int > const &", unperformed: "std::vector< int > const &") -> "void":
        return _pywrapcp.SequenceVarElement_SetSequence(self, forward_sequence, backward_sequence, unperformed)

    def SetForwardSequence(self, forward_sequence: "std::vector< int > const &") -> "void":
        return _pywrapcp.SequenceVarElement_SetForwardSequence(self, forward_sequence)

    def SetBackwardSequence(self, backward_sequence: "std::vector< int > const &") -> "void":
        return _pywrapcp.SequenceVarElement_SetBackwardSequence(self, backward_sequence)

    def SetUnperformed(self, unperformed: "std::vector< int > const &") -> "void":
        return _pywrapcp.SequenceVarElement_SetUnperformed(self, unperformed)

    def __eq__(self, element: "SequenceVarElement") -> "bool":
        return _pywrapcp.SequenceVarElement___eq__(self, element)

    def __ne__(self, element: "SequenceVarElement") -> "bool":
        return _pywrapcp.SequenceVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarElement

# Register SequenceVarElement in _pywrapcp:
_pywrapcp.SequenceVarElement_swigregister(SequenceVarElement)

class Assignment(PropagationBaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self) -> "void":
        return _pywrapcp.Assignment_Clear(self)

    def Empty(self) -> "bool":
        return _pywrapcp.Assignment_Empty(self)

    def Size(self) -> "int":
        return _pywrapcp.Assignment_Size(self)

    def NumIntVars(self) -> "int":
        return _pywrapcp.Assignment_NumIntVars(self)

    def NumIntervalVars(self) -> "int":
        return _pywrapcp.Assignment_NumIntervalVars(self)

    def NumSequenceVars(self) -> "int":
        return _pywrapcp.Assignment_NumSequenceVars(self)

    def Store(self) -> "void":
        return _pywrapcp.Assignment_Store(self)

    def Restore(self) -> "void":
        return _pywrapcp.Assignment_Restore(self)

    def Load(self, *args) -> "void":
        return _pywrapcp.Assignment_Load(self, *args)

    def Save(self, *args) -> "void":
        return _pywrapcp.Assignment_Save(self, *args)

    def AddObjective(self, v: "IntVar") -> "void":
        return _pywrapcp.Assignment_AddObjective(self, v)

    def Objective(self) -> "operations_research::IntVar *":
        return _pywrapcp.Assignment_Objective(self)

    def HasObjective(self) -> "bool":
        return _pywrapcp.Assignment_HasObjective(self)

    def ObjectiveMin(self) -> "int64":
        return _pywrapcp.Assignment_ObjectiveMin(self)

    def ObjectiveMax(self) -> "int64":
        return _pywrapcp.Assignment_ObjectiveMax(self)

    def ObjectiveValue(self) -> "int64":
        return _pywrapcp.Assignment_ObjectiveValue(self)

    def ObjectiveBound(self) -> "bool":
        return _pywrapcp.Assignment_ObjectiveBound(self)

    def SetObjectiveMin(self, m: "int64") -> "void":
        return _pywrapcp.Assignment_SetObjectiveMin(self, m)

    def SetObjectiveMax(self, m: "int64") -> "void":
        return _pywrapcp.Assignment_SetObjectiveMax(self, m)

    def SetObjectiveValue(self, value: "int64") -> "void":
        return _pywrapcp.Assignment_SetObjectiveValue(self, value)

    def SetObjectiveRange(self, l: "int64", u: "int64") -> "void":
        return _pywrapcp.Assignment_SetObjectiveRange(self, l, u)

    def Min(self, var: "IntVar") -> "int64":
        return _pywrapcp.Assignment_Min(self, var)

    def Max(self, var: "IntVar") -> "int64":
        return _pywrapcp.Assignment_Max(self, var)

    def Value(self, var: "IntVar") -> "int64":
        return _pywrapcp.Assignment_Value(self, var)

    def Bound(self, var: "IntVar") -> "bool":
        return _pywrapcp.Assignment_Bound(self, var)

    def SetMin(self, var: "IntVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetMin(self, var, m)

    def SetMax(self, var: "IntVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetMax(self, var, m)

    def SetRange(self, var: "IntVar", l: "int64", u: "int64") -> "void":
        return _pywrapcp.Assignment_SetRange(self, var, l, u)

    def SetValue(self, var: "IntVar", value: "int64") -> "void":
        return _pywrapcp.Assignment_SetValue(self, var, value)

    def StartMin(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_StartMin(self, var)

    def StartMax(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_StartMax(self, var)

    def StartValue(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_StartValue(self, var)

    def DurationMin(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_DurationMin(self, var)

    def DurationMax(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_DurationMax(self, var)

    def DurationValue(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_DurationValue(self, var)

    def EndMin(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_EndMin(self, var)

    def EndMax(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_EndMax(self, var)

    def EndValue(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_EndValue(self, var)

    def PerformedMin(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_PerformedMin(self, var)

    def PerformedMax(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_PerformedMax(self, var)

    def PerformedValue(self, var: "IntervalVar") -> "int64":
        return _pywrapcp.Assignment_PerformedValue(self, var)

    def SetStartMin(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetStartMin(self, var, m)

    def SetStartMax(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetStartMax(self, var, m)

    def SetStartRange(self, var: "IntervalVar", mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.Assignment_SetStartRange(self, var, mi, ma)

    def SetStartValue(self, var: "IntervalVar", value: "int64") -> "void":
        return _pywrapcp.Assignment_SetStartValue(self, var, value)

    def SetDurationMin(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetDurationMin(self, var, m)

    def SetDurationMax(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetDurationMax(self, var, m)

    def SetDurationRange(self, var: "IntervalVar", mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.Assignment_SetDurationRange(self, var, mi, ma)

    def SetDurationValue(self, var: "IntervalVar", value: "int64") -> "void":
        return _pywrapcp.Assignment_SetDurationValue(self, var, value)

    def SetEndMin(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetEndMin(self, var, m)

    def SetEndMax(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetEndMax(self, var, m)

    def SetEndRange(self, var: "IntervalVar", mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.Assignment_SetEndRange(self, var, mi, ma)

    def SetEndValue(self, var: "IntervalVar", value: "int64") -> "void":
        return _pywrapcp.Assignment_SetEndValue(self, var, value)

    def SetPerformedMin(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetPerformedMin(self, var, m)

    def SetPerformedMax(self, var: "IntervalVar", m: "int64") -> "void":
        return _pywrapcp.Assignment_SetPerformedMax(self, var, m)

    def SetPerformedRange(self, var: "IntervalVar", mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.Assignment_SetPerformedRange(self, var, mi, ma)

    def SetPerformedValue(self, var: "IntervalVar", value: "int64") -> "void":
        return _pywrapcp.Assignment_SetPerformedValue(self, var, value)

    def Add(self, *args) -> "void":
        return _pywrapcp.Assignment_Add(self, *args)

    def ForwardSequence(self, var: "SequenceVar") -> "std::vector< int > const &":
        return _pywrapcp.Assignment_ForwardSequence(self, var)

    def BackwardSequence(self, var: "SequenceVar") -> "std::vector< int > const &":
        return _pywrapcp.Assignment_BackwardSequence(self, var)

    def Unperformed(self, var: "SequenceVar") -> "std::vector< int > const &":
        return _pywrapcp.Assignment_Unperformed(self, var)

    def SetSequence(self, var: "SequenceVar", forward_sequence: "std::vector< int > const &", backward_sequence: "std::vector< int > const &", unperformed: "std::vector< int > const &") -> "void":
        return _pywrapcp.Assignment_SetSequence(self, var, forward_sequence, backward_sequence, unperformed)

    def SetForwardSequence(self, var: "SequenceVar", forward_sequence: "std::vector< int > const &") -> "void":
        return _pywrapcp.Assignment_SetForwardSequence(self, var, forward_sequence)

    def SetBackwardSequence(self, var: "SequenceVar", backward_sequence: "std::vector< int > const &") -> "void":
        return _pywrapcp.Assignment_SetBackwardSequence(self, var, backward_sequence)

    def SetUnperformed(self, var: "SequenceVar", unperformed: "std::vector< int > const &") -> "void":
        return _pywrapcp.Assignment_SetUnperformed(self, var, unperformed)

    def Activate(self, *args) -> "void":
        return _pywrapcp.Assignment_Activate(self, *args)

    def Deactivate(self, *args) -> "void":
        return _pywrapcp.Assignment_Deactivate(self, *args)

    def Activated(self, *args) -> "bool":
        return _pywrapcp.Assignment_Activated(self, *args)

    def DebugString(self) -> "std::string":
        return _pywrapcp.Assignment_DebugString(self)

    def IntVarContainer(self) -> "operations_research::Assignment::IntContainer const &":
        return _pywrapcp.Assignment_IntVarContainer(self)

    def MutableIntVarContainer(self) -> "operations_research::Assignment::IntContainer *":
        return _pywrapcp.Assignment_MutableIntVarContainer(self)

    def IntervalVarContainer(self) -> "operations_research::Assignment::IntervalContainer const &":
        return _pywrapcp.Assignment_IntervalVarContainer(self)

    def MutableIntervalVarContainer(self) -> "operations_research::Assignment::IntervalContainer *":
        return _pywrapcp.Assignment_MutableIntervalVarContainer(self)

    def SequenceVarContainer(self) -> "operations_research::Assignment::SequenceContainer const &":
        return _pywrapcp.Assignment_SequenceVarContainer(self)

    def MutableSequenceVarContainer(self) -> "operations_research::Assignment::SequenceContainer *":
        return _pywrapcp.Assignment_MutableSequenceVarContainer(self)

    def __eq__(self, assignment: "Assignment") -> "bool":
        return _pywrapcp.Assignment___eq__(self, assignment)

    def __ne__(self, assignment: "Assignment") -> "bool":
        return _pywrapcp.Assignment___ne__(self, assignment)

# Register Assignment in _pywrapcp:
_pywrapcp.Assignment_swigregister(Assignment)


def __lshift__(*args) -> "std::ostream &":
    return _pywrapcp.__lshift__(*args)
class Pack(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddWeightedSumLessOrEqualConstantDimension(self, *args) -> "void":
        return _pywrapcp.Pack_AddWeightedSumLessOrEqualConstantDimension(self, *args)

    def AddWeightedSumEqualVarDimension(self, *args) -> "void":
        return _pywrapcp.Pack_AddWeightedSumEqualVarDimension(self, *args)

    def AddSumVariableWeightsLessOrEqualConstantDimension(self, usage: "std::vector< operations_research::IntVar * > const &", capacity: "std::vector< int64 > const &") -> "void":
        return _pywrapcp.Pack_AddSumVariableWeightsLessOrEqualConstantDimension(self, usage, capacity)

    def AddWeightedSumOfAssignedDimension(self, weights: "std::vector< int64 > const &", cost_var: "IntVar") -> "void":
        return _pywrapcp.Pack_AddWeightedSumOfAssignedDimension(self, weights, cost_var)

    def AddCountUsedBinDimension(self, count_var: "IntVar") -> "void":
        return _pywrapcp.Pack_AddCountUsedBinDimension(self, count_var)

    def AddCountAssignedItemsDimension(self, count_var: "IntVar") -> "void":
        return _pywrapcp.Pack_AddCountAssignedItemsDimension(self, count_var)

    def Post(self) -> "void":
        return _pywrapcp.Pack_Post(self)

    def InitialPropagateWrapper(self) -> "void":
        return _pywrapcp.Pack_InitialPropagateWrapper(self)

    def DebugString(self) -> "std::string":
        return _pywrapcp.Pack_DebugString(self)

# Register Pack in _pywrapcp:
_pywrapcp.Pack_swigregister(Pack)

class DisjunctiveConstraint(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SequenceVar(self) -> "operations_research::SequenceVar *":
        return _pywrapcp.DisjunctiveConstraint_SequenceVar(self)

    def SetTransitionTime(self, transition_time: "operations_research::Solver::IndexEvaluator2") -> "void":
        return _pywrapcp.DisjunctiveConstraint_SetTransitionTime(self, transition_time)

    def TransitionTime(self, before_index: "int", after_index: "int") -> "int64":
        return _pywrapcp.DisjunctiveConstraint_TransitionTime(self, before_index, after_index)

# Register DisjunctiveConstraint in _pywrapcp:
_pywrapcp.DisjunctiveConstraint_swigregister(DisjunctiveConstraint)

class RevInteger(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, val: "long long const &"):
        _pywrapcp.RevInteger_swiginit(self, _pywrapcp.new_RevInteger(val))

    def Value(self) -> "long long const &":
        return _pywrapcp.RevInteger_Value(self)

    def SetValue(self, s: "Solver", val: "long long const &") -> "void":
        return _pywrapcp.RevInteger_SetValue(self, s, val)
    __swig_destroy__ = _pywrapcp.delete_RevInteger

# Register RevInteger in _pywrapcp:
_pywrapcp.RevInteger_swigregister(RevInteger)

class NumericalRevInteger(RevInteger):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, val: "long long const &"):
        _pywrapcp.NumericalRevInteger_swiginit(self, _pywrapcp.new_NumericalRevInteger(val))

    def Add(self, s: "Solver", to_add: "long long const &") -> "void":
        return _pywrapcp.NumericalRevInteger_Add(self, s, to_add)

    def Incr(self, s: "Solver") -> "void":
        return _pywrapcp.NumericalRevInteger_Incr(self, s)

    def Decr(self, s: "Solver") -> "void":
        return _pywrapcp.NumericalRevInteger_Decr(self, s)
    __swig_destroy__ = _pywrapcp.delete_NumericalRevInteger

# Register NumericalRevInteger in _pywrapcp:
_pywrapcp.NumericalRevInteger_swigregister(NumericalRevInteger)

class RevBool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, val: "bool const &"):
        _pywrapcp.RevBool_swiginit(self, _pywrapcp.new_RevBool(val))

    def Value(self) -> "bool const &":
        return _pywrapcp.RevBool_Value(self)

    def SetValue(self, s: "Solver", val: "bool const &") -> "void":
        return _pywrapcp.RevBool_SetValue(self, s, val)
    __swig_destroy__ = _pywrapcp.delete_RevBool

# Register RevBool in _pywrapcp:
_pywrapcp.RevBool_swigregister(RevBool)

class IntVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Contains(self, var: "IntVar") -> "bool":
        return _pywrapcp.IntVarContainer_Contains(self, var)

    def Element(self, index: "int") -> "operations_research::IntVarElement *":
        return _pywrapcp.IntVarContainer_Element(self, index)

    def Size(self) -> "int":
        return _pywrapcp.IntVarContainer_Size(self)

    def Store(self) -> "void":
        return _pywrapcp.IntVarContainer_Store(self)

    def Restore(self) -> "void":
        return _pywrapcp.IntVarContainer_Restore(self)

    def __eq__(self, container: "IntVarContainer") -> "bool":
        return _pywrapcp.IntVarContainer___eq__(self, container)

    def __ne__(self, container: "IntVarContainer") -> "bool":
        return _pywrapcp.IntVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_IntVarContainer

# Register IntVarContainer in _pywrapcp:
_pywrapcp.IntVarContainer_swigregister(IntVarContainer)

class IntervalVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Contains(self, var: "IntervalVar") -> "bool":
        return _pywrapcp.IntervalVarContainer_Contains(self, var)

    def Element(self, index: "int") -> "operations_research::IntervalVarElement *":
        return _pywrapcp.IntervalVarContainer_Element(self, index)

    def Size(self) -> "int":
        return _pywrapcp.IntervalVarContainer_Size(self)

    def Store(self) -> "void":
        return _pywrapcp.IntervalVarContainer_Store(self)

    def Restore(self) -> "void":
        return _pywrapcp.IntervalVarContainer_Restore(self)

    def __eq__(self, container: "IntervalVarContainer") -> "bool":
        return _pywrapcp.IntervalVarContainer___eq__(self, container)

    def __ne__(self, container: "IntervalVarContainer") -> "bool":
        return _pywrapcp.IntervalVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarContainer

# Register IntervalVarContainer in _pywrapcp:
_pywrapcp.IntervalVarContainer_swigregister(IntervalVarContainer)

class SequenceVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Contains(self, var: "SequenceVar") -> "bool":
        return _pywrapcp.SequenceVarContainer_Contains(self, var)

    def Element(self, index: "int") -> "operations_research::SequenceVarElement *":
        return _pywrapcp.SequenceVarContainer_Element(self, index)

    def Size(self) -> "int":
        return _pywrapcp.SequenceVarContainer_Size(self)

    def Store(self) -> "void":
        return _pywrapcp.SequenceVarContainer_Store(self)

    def Restore(self) -> "void":
        return _pywrapcp.SequenceVarContainer_Restore(self)

    def __eq__(self, container: "SequenceVarContainer") -> "bool":
        return _pywrapcp.SequenceVarContainer___eq__(self, container)

    def __ne__(self, container: "SequenceVarContainer") -> "bool":
        return _pywrapcp.SequenceVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarContainer

# Register SequenceVarContainer in _pywrapcp:
_pywrapcp.SequenceVarContainer_swigregister(SequenceVarContainer)

class LocalSearchOperator(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NextNeighbor(self, delta: "Assignment", deltadelta: "Assignment") -> "bool":
        return _pywrapcp.LocalSearchOperator_NextNeighbor(self, delta, deltadelta)

    def Start(self, assignment: "Assignment") -> "void":
        return _pywrapcp.LocalSearchOperator_Start(self, assignment)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_LocalSearchOperator(self)
        return weakref.proxy(self)

# Register LocalSearchOperator in _pywrapcp:
_pywrapcp.LocalSearchOperator_swigregister(LocalSearchOperator)

class IntVarLocalSearchOperatorTemplate(LocalSearchOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Start(self, assignment: "Assignment") -> "void":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Start(self, assignment)

    def IsIncremental(self) -> "bool":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_IsIncremental(self)

    def Size(self) -> "int":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Size(self)

    def Value(self, index: "int64") -> "long long const &":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Value(self, index)

    def OldValue(self, index: "int64") -> "long long const &":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_OldValue(self, index)

    def SetValue(self, index: "int64", value: "long long const &") -> "void":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_SetValue(self, index, value)

    def OnStart(self) -> "void":
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_OnStart(self)

# Register IntVarLocalSearchOperatorTemplate in _pywrapcp:
_pywrapcp.IntVarLocalSearchOperatorTemplate_swigregister(IntVarLocalSearchOperatorTemplate)

class IntVarLocalSearchOperator(IntVarLocalSearchOperatorTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == IntVarLocalSearchOperator:
            _self = None
        else:
            _self = self
        _pywrapcp.IntVarLocalSearchOperator_swiginit(self, _pywrapcp.new_IntVarLocalSearchOperator(_self, *args))
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchOperator

    def NextNeighbor(self, delta: "Assignment", deltadelta: "Assignment") -> "bool":
        return _pywrapcp.IntVarLocalSearchOperator_NextNeighbor(self, delta, deltadelta)

    def OneNeighbor(self) -> "bool":
        return _pywrapcp.IntVarLocalSearchOperator_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchOperator(self)
        return weakref.proxy(self)

# Register IntVarLocalSearchOperator in _pywrapcp:
_pywrapcp.IntVarLocalSearchOperator_swigregister(IntVarLocalSearchOperator)

class SequenceVarLocalSearchOperatorTemplate(LocalSearchOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Start(self, assignment: "Assignment") -> "void":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Start(self, assignment)

    def IsIncremental(self) -> "bool":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_IsIncremental(self)

    def Size(self) -> "int":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Size(self)

    def Value(self, index: "int64") -> "std::vector< int > const &":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Value(self, index)

    def OldValue(self, index: "int64") -> "std::vector< int > const &":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OldValue(self, index)

    def SetValue(self, index: "int64", value: "std::vector< int > const &") -> "void":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_SetValue(self, index, value)

    def OnStart(self) -> "void":
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OnStart(self)

# Register SequenceVarLocalSearchOperatorTemplate in _pywrapcp:
_pywrapcp.SequenceVarLocalSearchOperatorTemplate_swigregister(SequenceVarLocalSearchOperatorTemplate)

class SequenceVarLocalSearchOperator(SequenceVarLocalSearchOperatorTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register SequenceVarLocalSearchOperator in _pywrapcp:
_pywrapcp.SequenceVarLocalSearchOperator_swigregister(SequenceVarLocalSearchOperator)

class BaseLns(IntVarLocalSearchOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vars: "std::vector< operations_research::IntVar * > const &"):
        if self.__class__ == BaseLns:
            _self = None
        else:
            _self = self
        _pywrapcp.BaseLns_swiginit(self, _pywrapcp.new_BaseLns(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_BaseLns

    def InitFragments(self) -> "void":
        return _pywrapcp.BaseLns_InitFragments(self)

    def NextFragment(self) -> "bool":
        return _pywrapcp.BaseLns_NextFragment(self)

    def AppendToFragment(self, index: "int") -> "void":
        return _pywrapcp.BaseLns_AppendToFragment(self, index)

    def FragmentSize(self) -> "int":
        return _pywrapcp.BaseLns_FragmentSize(self)

    def __getitem__(self, index: "int") -> "int64":
        return _pywrapcp.BaseLns___getitem__(self, index)

    def __len__(self) -> "int":
        return _pywrapcp.BaseLns___len__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseLns(self)
        return weakref.proxy(self)

# Register BaseLns in _pywrapcp:
_pywrapcp.BaseLns_swigregister(BaseLns)

class ChangeValue(IntVarLocalSearchOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vars: "std::vector< operations_research::IntVar * > const &"):
        if self.__class__ == ChangeValue:
            _self = None
        else:
            _self = self
        _pywrapcp.ChangeValue_swiginit(self, _pywrapcp.new_ChangeValue(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_ChangeValue

    def ModifyValue(self, index: "int64", value: "int64") -> "int64":
        return _pywrapcp.ChangeValue_ModifyValue(self, index, value)

    def OneNeighbor(self) -> "bool":
        return _pywrapcp.ChangeValue_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_ChangeValue(self)
        return weakref.proxy(self)

# Register ChangeValue in _pywrapcp:
_pywrapcp.ChangeValue_swigregister(ChangeValue)

class PathOperator(IntVarLocalSearchOperator):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Neighbor(self) -> "bool":
        return _pywrapcp.PathOperator_Neighbor(self)

# Register PathOperator in _pywrapcp:
_pywrapcp.PathOperator_swigregister(PathOperator)

class LocalSearchFilter(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, delta: "Assignment", deltadelta: "Assignment", objective_min: "int64", objective_max: "int64") -> "bool":
        return _pywrapcp.LocalSearchFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def IsIncremental(self) -> "bool":
        return _pywrapcp.LocalSearchFilter_IsIncremental(self)

    def Synchronize(self, assignment: "Assignment", delta: "Assignment") -> "void":
        return _pywrapcp.LocalSearchFilter_Synchronize(self, assignment, delta)
    __swig_destroy__ = _pywrapcp.delete_LocalSearchFilter

# Register LocalSearchFilter in _pywrapcp:
_pywrapcp.LocalSearchFilter_swigregister(LocalSearchFilter)

class IntVarLocalSearchFilter(LocalSearchFilter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, vars: "std::vector< operations_research::IntVar * > const &"):
        if self.__class__ == IntVarLocalSearchFilter:
            _self = None
        else:
            _self = self
        _pywrapcp.IntVarLocalSearchFilter_swiginit(self, _pywrapcp.new_IntVarLocalSearchFilter(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchFilter

    def Synchronize(self, assignment: "Assignment", delta: "Assignment") -> "void":
        return _pywrapcp.IntVarLocalSearchFilter_Synchronize(self, assignment, delta)

    def Size(self) -> "int":
        return _pywrapcp.IntVarLocalSearchFilter_Size(self)

    def Value(self, index: "int") -> "int64":
        return _pywrapcp.IntVarLocalSearchFilter_Value(self, index)

    def IndexFromVar(self, var: "IntVar") -> "int64":
        return _pywrapcp.IntVarLocalSearchFilter_IndexFromVar(self, var)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchFilter(self)
        return weakref.proxy(self)

# Register IntVarLocalSearchFilter in _pywrapcp:
_pywrapcp.IntVarLocalSearchFilter_swigregister(IntVarLocalSearchFilter)

class BooleanVar(IntVar):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Min(self) -> "int64":
        return _pywrapcp.BooleanVar_Min(self)

    def SetMin(self, m: "int64") -> "void":
        return _pywrapcp.BooleanVar_SetMin(self, m)

    def Max(self) -> "int64":
        return _pywrapcp.BooleanVar_Max(self)

    def SetMax(self, m: "int64") -> "void":
        return _pywrapcp.BooleanVar_SetMax(self, m)

    def SetRange(self, mi: "int64", ma: "int64") -> "void":
        return _pywrapcp.BooleanVar_SetRange(self, mi, ma)

    def Bound(self) -> "bool":
        return _pywrapcp.BooleanVar_Bound(self)

    def Value(self) -> "int64":
        return _pywrapcp.BooleanVar_Value(self)

    def RemoveValue(self, v: "int64") -> "void":
        return _pywrapcp.BooleanVar_RemoveValue(self, v)

    def RemoveInterval(self, l: "int64", u: "int64") -> "void":
        return _pywrapcp.BooleanVar_RemoveInterval(self, l, u)

    def WhenBound(self, d: "Demon") -> "void":
        return _pywrapcp.BooleanVar_WhenBound(self, d)

    def WhenRange(self, d: "Demon") -> "void":
        return _pywrapcp.BooleanVar_WhenRange(self, d)

    def WhenDomain(self, d: "Demon") -> "void":
        return _pywrapcp.BooleanVar_WhenDomain(self, d)

    def Size(self) -> "uint64":
        return _pywrapcp.BooleanVar_Size(self)

    def Contains(self, v: "int64") -> "bool":
        return _pywrapcp.BooleanVar_Contains(self, v)

    def HoleIteratorAux(self, reversible: "bool") -> "operations_research::IntVarIterator *":
        return _pywrapcp.BooleanVar_HoleIteratorAux(self, reversible)

    def DomainIteratorAux(self, reversible: "bool") -> "operations_research::IntVarIterator *":
        return _pywrapcp.BooleanVar_DomainIteratorAux(self, reversible)

    def DebugString(self) -> "std::string":
        return _pywrapcp.BooleanVar_DebugString(self)

# Register BooleanVar in _pywrapcp:
_pywrapcp.BooleanVar_swigregister(BooleanVar)


class PyDecision(Decision):

  def __init__(self):
    Decision.__init__(self)

  def ApplyWrapper(self, solver):
    try:
       self.Apply(solver)
    except Exception as e:
      if 'CP Solver fail' in str(e):
        solver.ShouldFail()
      else:
        raise

  def RefuteWrapper(self, solver):
    try:
       self.Refute(solver)
    except Exception as e:
      if 'CP Solver fail' in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return "PyDecision"


class PyDecisionBuilder(DecisionBuilder):

  def __init__(self):
    DecisionBuilder.__init__(self)

  def NextWrapper(self, solver):
    try:
      return self.Next(solver)
    except Exception as e:
      if 'CP Solver fail' in str(e):
        return solver.FailDecision()
      else:
        raise

  def DebugString(self):
    return "PyDecisionBuilder"


class PyDemon(Demon):

  def RunWrapper(self, solver):
    try:
      self.Run(solver)
    except Exception as e:
      if 'CP Solver fail' in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return "PyDemon"


class PyConstraintDemon(PyDemon):

  def __init__(self, ct, method, delayed, *args):
    PyDemon.__init__(self)
    self.__constraint = ct
    self.__method = method
    self.__delayed = delayed
    self.__args = args

  def Run(self, solver):
    self.__method(self.__constraint, *self.__args)

  def Priority(self):
    return Solver.DELAYED_PRIORITY if self.__delayed else Solver.NORMAL_PRIORITY

  def DebugString(self):
    return 'PyConstraintDemon'


class PyConstraint(Constraint):

  def __init__(self, solver):
    Constraint.__init__(self, solver)
    self.__demons = []

  def Demon(self, method, *args):
    demon = PyConstraintDemon(self, method, False, *args)
    self.__demons.append(demon)
    return demon

  def DelayedDemon(self, method, *args):
    demon = PyConstraintDemon(self, method, True, *args)
    self.__demons.append(demon)
    return demon

  def InitialPropagateDemon(self):
    return self.solver().ConstraintInitialPropagateCallback(self)

  def DelayedInitialPropagateDemon(self):
    return self.solver().DelayedConstraintInitialPropagateCallback(self)

  def InitialPropagateWrapper(self):
    try:
      self.InitialPropagate()
    except Exception as e:
      if 'CP Solver fail' in str(e):
        self.solver().ShouldFail()
      else:
        raise

  def DebugString(self):
    return "PyConstraint"



class RoutingIndexManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pywrapcp.RoutingIndexManager_swiginit(self, _pywrapcp.new_RoutingIndexManager(*args))
    __swig_destroy__ = _pywrapcp.delete_RoutingIndexManager

    def GetNumberOfNodes(self) -> "int":
        return _pywrapcp.RoutingIndexManager_GetNumberOfNodes(self)

    def GetNumberOfVehicles(self) -> "int":
        return _pywrapcp.RoutingIndexManager_GetNumberOfVehicles(self)

    def GetNumberOfIndices(self) -> "int":
        return _pywrapcp.RoutingIndexManager_GetNumberOfIndices(self)

    def NodeToIndex(self, node: "operations_research::RoutingIndexManager::NodeIndex") -> "int64":
        return _pywrapcp.RoutingIndexManager_NodeToIndex(self, node)

    def IndexToNode(self, index: "int64") -> "operations_research::RoutingIndexManager::NodeIndex":
        return _pywrapcp.RoutingIndexManager_IndexToNode(self, index)

# Register RoutingIndexManager in _pywrapcp:
_pywrapcp.RoutingIndexManager_swigregister(RoutingIndexManager)


def DefaultRoutingModelParameters() -> "operations_research::RoutingModelParameters":
    return _pywrapcp.DefaultRoutingModelParameters()

def DefaultRoutingSearchParameters() -> "operations_research::RoutingSearchParameters":
    return _pywrapcp.DefaultRoutingSearchParameters()

def FindErrorInRoutingSearchParameters(search_parameters: "operations_research::RoutingSearchParameters const &") -> "std::string":
    return _pywrapcp.FindErrorInRoutingSearchParameters(search_parameters)
BOOL_UNSPECIFIED = _pywrapcp.BOOL_UNSPECIFIED
BOOL_FALSE = _pywrapcp.BOOL_FALSE
BOOL_TRUE = _pywrapcp.BOOL_TRUE
class RoutingModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ROUTING_NOT_SOLVED = _pywrapcp.RoutingModel_ROUTING_NOT_SOLVED
    ROUTING_SUCCESS = _pywrapcp.RoutingModel_ROUTING_SUCCESS
    ROUTING_FAIL = _pywrapcp.RoutingModel_ROUTING_FAIL
    ROUTING_FAIL_TIMEOUT = _pywrapcp.RoutingModel_ROUTING_FAIL_TIMEOUT
    ROUTING_INVALID = _pywrapcp.RoutingModel_ROUTING_INVALID
    PICKUP_AND_DELIVERY_NO_ORDER = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_NO_ORDER
    PICKUP_AND_DELIVERY_LIFO = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_LIFO
    PICKUP_AND_DELIVERY_FIFO = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_FIFO

    def __init__(self, *args):
        _pywrapcp.RoutingModel_swiginit(self, _pywrapcp.new_RoutingModel(*args))
    __swig_destroy__ = _pywrapcp.delete_RoutingModel

    def RegisterUnaryTransitCallback(self, callback: "operations_research::RoutingModel::TransitCallback1") -> "int":
        return _pywrapcp.RoutingModel_RegisterUnaryTransitCallback(self, callback)

    def RegisterPositiveUnaryTransitCallback(self, callback: "operations_research::RoutingModel::TransitCallback1") -> "int":
        return _pywrapcp.RoutingModel_RegisterPositiveUnaryTransitCallback(self, callback)

    def RegisterTransitCallback(self, callback: "operations_research::RoutingModel::TransitCallback2") -> "int":
        return _pywrapcp.RoutingModel_RegisterTransitCallback(self, callback)

    def RegisterPositiveTransitCallback(self, callback: "operations_research::RoutingModel::TransitCallback2") -> "int":
        return _pywrapcp.RoutingModel_RegisterPositiveTransitCallback(self, callback)

    def TransitCallback(self, callback_index: "int") -> "operations_research::RoutingModel::TransitCallback2 const &":
        return _pywrapcp.RoutingModel_TransitCallback(self, callback_index)

    def UnaryTransitCallbackOrNull(self, callback_index: "int") -> "operations_research::RoutingModel::TransitCallback1 const &":
        return _pywrapcp.RoutingModel_UnaryTransitCallbackOrNull(self, callback_index)

    def AddDimension(self, evaluator_index: "int", slack_max: "int64", capacity: "int64", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddDimension(self, evaluator_index, slack_max, capacity, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleTransits(self, evaluator_indices: "std::vector< int > const &", slack_max: "int64", capacity: "int64", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransits(self, evaluator_indices, slack_max, capacity, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleCapacity(self, evaluator_index: "int", slack_max: "int64", vehicle_capacities: "std::vector< int64 >", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleCapacity(self, evaluator_index, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices: "std::vector< int > const &", slack_max: "int64", vehicle_capacities: "std::vector< int64 >", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)

    def AddConstantDimensionWithSlack(self, value: "int64", capacity: "int64", slack_max: "int64", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddConstantDimensionWithSlack(self, value, capacity, slack_max, fix_start_cumul_to_zero, name)

    def AddConstantDimension(self, value: "int64", capacity: "int64", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddConstantDimension(self, value, capacity, fix_start_cumul_to_zero, name)

    def AddVectorDimension(self, values: "std::vector< int64 >", capacity: "int64", fix_start_cumul_to_zero: "bool", name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_AddVectorDimension(self, values, capacity, fix_start_cumul_to_zero, name)

    def MakePathSpansAndTotalSlacks(self, dimension: "RoutingDimension", spans: "std::vector< operations_research::IntVar * >", total_slacks: "std::vector< operations_research::IntVar * >") -> "operations_research::Constraint *":
        return _pywrapcp.RoutingModel_MakePathSpansAndTotalSlacks(self, dimension, spans, total_slacks)

    def GetAllDimensionNames(self) -> "std::vector< std::string >":
        return _pywrapcp.RoutingModel_GetAllDimensionNames(self)

    def GetDimensions(self) -> "std::vector< operations_research::RoutingDimension * > const &":
        return _pywrapcp.RoutingModel_GetDimensions(self)

    def GetDimensionsWithSoftOrSpanCosts(self) -> "std::vector< operations_research::RoutingDimension * >":
        return _pywrapcp.RoutingModel_GetDimensionsWithSoftOrSpanCosts(self)

    def GetGlobalDimensionCumulOptimizers(self) -> "std::vector< std::unique_ptr< operations_research::GlobalDimensionCumulOptimizer > > const &":
        return _pywrapcp.RoutingModel_GetGlobalDimensionCumulOptimizers(self)

    def GetLocalDimensionCumulOptimizers(self) -> "std::vector< std::unique_ptr< operations_research::LocalDimensionCumulOptimizer > > const &":
        return _pywrapcp.RoutingModel_GetLocalDimensionCumulOptimizers(self)

    def GetLocalDimensionCumulMPOptimizers(self) -> "std::vector< std::unique_ptr< operations_research::LocalDimensionCumulOptimizer > > const &":
        return _pywrapcp.RoutingModel_GetLocalDimensionCumulMPOptimizers(self)

    def GetMutableGlobalCumulOptimizer(self, dimension: "RoutingDimension") -> "operations_research::GlobalDimensionCumulOptimizer *":
        return _pywrapcp.RoutingModel_GetMutableGlobalCumulOptimizer(self, dimension)

    def GetMutableLocalCumulOptimizer(self, dimension: "RoutingDimension") -> "operations_research::LocalDimensionCumulOptimizer *":
        return _pywrapcp.RoutingModel_GetMutableLocalCumulOptimizer(self, dimension)

    def GetMutableLocalCumulMPOptimizer(self, dimension: "RoutingDimension") -> "operations_research::LocalDimensionCumulOptimizer *":
        return _pywrapcp.RoutingModel_GetMutableLocalCumulMPOptimizer(self, dimension)

    def HasDimension(self, dimension_name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_HasDimension(self, dimension_name)

    def GetDimensionOrDie(self, dimension_name: "std::string const &") -> "operations_research::RoutingDimension const &":
        return _pywrapcp.RoutingModel_GetDimensionOrDie(self, dimension_name)

    def GetMutableDimension(self, dimension_name: "std::string const &") -> "operations_research::RoutingDimension *":
        return _pywrapcp.RoutingModel_GetMutableDimension(self, dimension_name)

    def SetPrimaryConstrainedDimension(self, dimension_name: "std::string const &") -> "void":
        return _pywrapcp.RoutingModel_SetPrimaryConstrainedDimension(self, dimension_name)

    def GetPrimaryConstrainedDimension(self) -> "std::string const &":
        return _pywrapcp.RoutingModel_GetPrimaryConstrainedDimension(self)

    def AddDisjunction(self, *args) -> "operations_research::RoutingModel::DisjunctionIndex":
        return _pywrapcp.RoutingModel_AddDisjunction(self, *args)

    def GetDisjunctionIndices(self, index: "int64") -> "std::vector< operations_research::RoutingModel::DisjunctionIndex > const &":
        return _pywrapcp.RoutingModel_GetDisjunctionIndices(self, index)

    def GetDisjunctionPenalty(self, index: "operations_research::RoutingModel::DisjunctionIndex") -> "int64":
        return _pywrapcp.RoutingModel_GetDisjunctionPenalty(self, index)

    def GetDisjunctionMaxCardinality(self, index: "operations_research::RoutingModel::DisjunctionIndex") -> "int64":
        return _pywrapcp.RoutingModel_GetDisjunctionMaxCardinality(self, index)

    def GetNumberOfDisjunctions(self) -> "int":
        return _pywrapcp.RoutingModel_GetNumberOfDisjunctions(self)

    def GetPerfectBinaryDisjunctions(self) -> "std::vector< std::pair< int64,int64 > >":
        return _pywrapcp.RoutingModel_GetPerfectBinaryDisjunctions(self)

    def IgnoreDisjunctionsAlreadyForcedToZero(self) -> "void":
        return _pywrapcp.RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero(self)

    def AddSoftSameVehicleConstraint(self, indices: "std::vector< int64 > const &", cost: "int64") -> "void":
        return _pywrapcp.RoutingModel_AddSoftSameVehicleConstraint(self, indices, cost)

    def SetAllowedVehiclesForIndex(self, vehicles: "std::vector< int > const &", index: "int64") -> "void":
        return _pywrapcp.RoutingModel_SetAllowedVehiclesForIndex(self, vehicles, index)

    def IsVehicleAllowedForIndex(self, vehicle: "int", index: "int64") -> "bool":
        return _pywrapcp.RoutingModel_IsVehicleAllowedForIndex(self, vehicle, index)

    def AddPickupAndDelivery(self, pickup: "int64", delivery: "int64") -> "void":
        return _pywrapcp.RoutingModel_AddPickupAndDelivery(self, pickup, delivery)

    def AddPickupAndDeliverySets(self, pickup_disjunction: "operations_research::RoutingModel::DisjunctionIndex", delivery_disjunction: "operations_research::RoutingModel::DisjunctionIndex") -> "void":
        return _pywrapcp.RoutingModel_AddPickupAndDeliverySets(self, pickup_disjunction, delivery_disjunction)

    def GetPickupIndexPairs(self, node_index: "int64") -> "std::vector< std::pair< int,int > > const &":
        return _pywrapcp.RoutingModel_GetPickupIndexPairs(self, node_index)

    def GetDeliveryIndexPairs(self, node_index: "int64") -> "std::vector< std::pair< int,int > > const &":
        return _pywrapcp.RoutingModel_GetDeliveryIndexPairs(self, node_index)

    def SetPickupAndDeliveryPolicyOfAllVehicles(self, policy: "operations_research::RoutingModel::PickupAndDeliveryPolicy") -> "void":
        return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles(self, policy)

    def SetPickupAndDeliveryPolicyOfVehicle(self, policy: "operations_research::RoutingModel::PickupAndDeliveryPolicy", vehicle: "int") -> "void":
        return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfVehicle(self, policy, vehicle)

    def GetPickupAndDeliveryPolicyOfVehicle(self, vehicle: "int") -> "operations_research::RoutingModel::PickupAndDeliveryPolicy":
        return _pywrapcp.RoutingModel_GetPickupAndDeliveryPolicyOfVehicle(self, vehicle)

    def GetNumOfSingletonNodes(self) -> "int":
        return _pywrapcp.RoutingModel_GetNumOfSingletonNodes(self)
    TYPE_ADDED_TO_VEHICLE = _pywrapcp.RoutingModel_TYPE_ADDED_TO_VEHICLE
    ADDED_TYPE_REMOVED_FROM_VEHICLE = _pywrapcp.RoutingModel_ADDED_TYPE_REMOVED_FROM_VEHICLE
    TYPE_ON_VEHICLE_UP_TO_VISIT = _pywrapcp.RoutingModel_TYPE_ON_VEHICLE_UP_TO_VISIT
    TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED = _pywrapcp.RoutingModel_TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED

    def SetVisitType(self, index: "int64", type: "int", type_policy: "operations_research::RoutingModel::VisitTypePolicy") -> "void":
        return _pywrapcp.RoutingModel_SetVisitType(self, index, type, type_policy)

    def GetVisitType(self, index: "int64") -> "int":
        return _pywrapcp.RoutingModel_GetVisitType(self, index)

    def GetVisitTypePolicy(self, index: "int64") -> "operations_research::RoutingModel::VisitTypePolicy":
        return _pywrapcp.RoutingModel_GetVisitTypePolicy(self, index)

    def CloseVisitTypes(self) -> "void":
        return _pywrapcp.RoutingModel_CloseVisitTypes(self)

    def GetNumberOfVisitTypes(self) -> "int":
        return _pywrapcp.RoutingModel_GetNumberOfVisitTypes(self)

    def AddHardTypeIncompatibility(self, type1: "int", type2: "int") -> "void":
        return _pywrapcp.RoutingModel_AddHardTypeIncompatibility(self, type1, type2)

    def AddTemporalTypeIncompatibility(self, type1: "int", type2: "int") -> "void":
        return _pywrapcp.RoutingModel_AddTemporalTypeIncompatibility(self, type1, type2)

    def GetHardTypeIncompatibilitiesOfType(self, type: "int") -> "absl::flat_hash_set< int > const &":
        return _pywrapcp.RoutingModel_GetHardTypeIncompatibilitiesOfType(self, type)

    def GetTemporalTypeIncompatibilitiesOfType(self, type: "int") -> "absl::flat_hash_set< int > const &":
        return _pywrapcp.RoutingModel_GetTemporalTypeIncompatibilitiesOfType(self, type)

    def HasHardTypeIncompatibilities(self) -> "bool":
        return _pywrapcp.RoutingModel_HasHardTypeIncompatibilities(self)

    def HasTemporalTypeIncompatibilities(self) -> "bool":
        return _pywrapcp.RoutingModel_HasTemporalTypeIncompatibilities(self)

    def AddSameVehicleRequiredTypeAlternatives(self, dependent_type: "int", required_type_alternatives: "absl::flat_hash_set< int >") -> "void":
        return _pywrapcp.RoutingModel_AddSameVehicleRequiredTypeAlternatives(self, dependent_type, required_type_alternatives)

    def AddRequiredTypeAlternativesWhenAddingType(self, dependent_type: "int", required_type_alternatives: "absl::flat_hash_set< int >") -> "void":
        return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenAddingType(self, dependent_type, required_type_alternatives)

    def AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type: "int", required_type_alternatives: "absl::flat_hash_set< int >") -> "void":
        return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type, required_type_alternatives)

    def GetSameVehicleRequiredTypeAlternativesOfType(self, type: "int") -> "std::vector< absl::flat_hash_set< int > > const &":
        return _pywrapcp.RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType(self, type)

    def GetRequiredTypeAlternativesWhenAddingType(self, type: "int") -> "std::vector< absl::flat_hash_set< int > > const &":
        return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenAddingType(self, type)

    def GetRequiredTypeAlternativesWhenRemovingType(self, type: "int") -> "std::vector< absl::flat_hash_set< int > > const &":
        return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenRemovingType(self, type)

    def HasSameVehicleTypeRequirements(self) -> "bool":
        return _pywrapcp.RoutingModel_HasSameVehicleTypeRequirements(self)

    def HasTemporalTypeRequirements(self) -> "bool":
        return _pywrapcp.RoutingModel_HasTemporalTypeRequirements(self)

    def HasTypeRegulations(self) -> "bool":
        return _pywrapcp.RoutingModel_HasTypeRegulations(self)

    def UnperformedPenalty(self, var_index: "int64") -> "int64":
        return _pywrapcp.RoutingModel_UnperformedPenalty(self, var_index)

    def UnperformedPenaltyOrValue(self, default_value: "int64", var_index: "int64") -> "int64":
        return _pywrapcp.RoutingModel_UnperformedPenaltyOrValue(self, default_value, var_index)

    def GetDepot(self) -> "int64":
        return _pywrapcp.RoutingModel_GetDepot(self)

    def SetArcCostEvaluatorOfAllVehicles(self, evaluator_index: "int") -> "void":
        return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfAllVehicles(self, evaluator_index)

    def SetArcCostEvaluatorOfVehicle(self, evaluator_index: "int", vehicle: "int") -> "void":
        return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfVehicle(self, evaluator_index, vehicle)

    def SetFixedCostOfAllVehicles(self, cost: "int64") -> "void":
        return _pywrapcp.RoutingModel_SetFixedCostOfAllVehicles(self, cost)

    def SetFixedCostOfVehicle(self, cost: "int64", vehicle: "int") -> "void":
        return _pywrapcp.RoutingModel_SetFixedCostOfVehicle(self, cost, vehicle)

    def GetFixedCostOfVehicle(self, vehicle: "int") -> "int64":
        return _pywrapcp.RoutingModel_GetFixedCostOfVehicle(self, vehicle)

    def SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor: "int64", quadratic_cost_factor: "int64") -> "void":
        return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor, quadratic_cost_factor)

    def SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor: "int64", quadratic_cost_factor: "int64", vehicle: "int") -> "void":
        return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor, quadratic_cost_factor, vehicle)

    def GetAmortizedLinearCostFactorOfVehicles(self) -> "std::vector< int64 > const &":
        return _pywrapcp.RoutingModel_GetAmortizedLinearCostFactorOfVehicles(self)

    def GetAmortizedQuadraticCostFactorOfVehicles(self) -> "std::vector< int64 > const &":
        return _pywrapcp.RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles(self)

    def ConsiderEmptyRouteCostsForVehicle(self, consider_costs: "bool", vehicle: "int") -> "void":
        return _pywrapcp.RoutingModel_ConsiderEmptyRouteCostsForVehicle(self, consider_costs, vehicle)

    def AreEmptyRouteCostsConsideredForVehicle(self, vehicle: "int") -> "bool":
        return _pywrapcp.RoutingModel_AreEmptyRouteCostsConsideredForVehicle(self, vehicle)

    def SetFirstSolutionEvaluator(self, evaluator: "operations_research::Solver::IndexEvaluator2") -> "void":
        return _pywrapcp.RoutingModel_SetFirstSolutionEvaluator(self, evaluator)

    def AddLocalSearchOperator(self, ls_operator: "LocalSearchOperator") -> "void":
        return _pywrapcp.RoutingModel_AddLocalSearchOperator(self, ls_operator)

    def AddSearchMonitor(self, monitor: "SearchMonitor") -> "void":
        return _pywrapcp.RoutingModel_AddSearchMonitor(self, monitor)

    def AddAtSolutionCallback(self, callback: "std::function< void () >") -> "void":
        return _pywrapcp.RoutingModel_AddAtSolutionCallback(self, callback)

    def AddVariableMinimizedByFinalizer(self, var: "IntVar") -> "void":
        return _pywrapcp.RoutingModel_AddVariableMinimizedByFinalizer(self, var)

    def AddVariableMaximizedByFinalizer(self, var: "IntVar") -> "void":
        return _pywrapcp.RoutingModel_AddVariableMaximizedByFinalizer(self, var)

    def AddWeightedVariableMinimizedByFinalizer(self, var: "IntVar", cost: "int64") -> "void":
        return _pywrapcp.RoutingModel_AddWeightedVariableMinimizedByFinalizer(self, var, cost)

    def AddVariableTargetToFinalizer(self, var: "IntVar", target: "int64") -> "void":
        return _pywrapcp.RoutingModel_AddVariableTargetToFinalizer(self, var, target)

    def CloseModel(self) -> "void":
        return _pywrapcp.RoutingModel_CloseModel(self)

    def CloseModelWithParameters(self, search_parameters: "operations_research::RoutingSearchParameters const &") -> "void":
        return _pywrapcp.RoutingModel_CloseModelWithParameters(self, search_parameters)

    def Solve(self, assignment: "Assignment"=None) -> "operations_research::Assignment const *":
        return _pywrapcp.RoutingModel_Solve(self, assignment)

    def SolveWithParameters(self, search_parameters: "operations_research::RoutingSearchParameters const &", solutions: "std::vector< operations_research::Assignment const * > *"=None) -> "operations_research::Assignment const *":
        return _pywrapcp.RoutingModel_SolveWithParameters(self, search_parameters, solutions)

    def SolveFromAssignmentWithParameters(self, assignment: "Assignment", search_parameters: "operations_research::RoutingSearchParameters const &", solutions: "std::vector< operations_research::Assignment const * > *"=None) -> "operations_research::Assignment const *":
        return _pywrapcp.RoutingModel_SolveFromAssignmentWithParameters(self, assignment, search_parameters, solutions)

    def SetAssignmentFromOtherModelAssignment(self, target_assignment: "Assignment", source_model: "RoutingModel", source_assignment: "Assignment") -> "void":
        return _pywrapcp.RoutingModel_SetAssignmentFromOtherModelAssignment(self, target_assignment, source_model, source_assignment)

    def ComputeLowerBound(self) -> "int64":
        return _pywrapcp.RoutingModel_ComputeLowerBound(self)

    def status(self) -> "operations_research::RoutingModel::Status":
        return _pywrapcp.RoutingModel_status(self)

    def ApplyLocks(self, locks: "std::vector< int64 > const &") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingModel_ApplyLocks(self, locks)

    def ApplyLocksToAllVehicles(self, locks: "std::vector< std::vector< int64 > > const &", close_routes: "bool") -> "bool":
        return _pywrapcp.RoutingModel_ApplyLocksToAllVehicles(self, locks, close_routes)

    def PreAssignment(self) -> "operations_research::Assignment const *const":
        return _pywrapcp.RoutingModel_PreAssignment(self)

    def MutablePreAssignment(self) -> "operations_research::Assignment *":
        return _pywrapcp.RoutingModel_MutablePreAssignment(self)

    def WriteAssignment(self, file_name: "std::string const &") -> "bool":
        return _pywrapcp.RoutingModel_WriteAssignment(self, file_name)

    def ReadAssignment(self, file_name: "std::string const &") -> "operations_research::Assignment *":
        return _pywrapcp.RoutingModel_ReadAssignment(self, file_name)

    def RestoreAssignment(self, solution: "Assignment") -> "operations_research::Assignment *":
        return _pywrapcp.RoutingModel_RestoreAssignment(self, solution)

    def ReadAssignmentFromRoutes(self, routes: "std::vector< std::vector< int64 > > const &", ignore_inactive_indices: "bool") -> "operations_research::Assignment *":
        return _pywrapcp.RoutingModel_ReadAssignmentFromRoutes(self, routes, ignore_inactive_indices)

    def RoutesToAssignment(self, routes: "std::vector< std::vector< int64 > > const &", ignore_inactive_indices: "bool", close_routes: "bool", assignment: "Assignment") -> "bool":
        return _pywrapcp.RoutingModel_RoutesToAssignment(self, routes, ignore_inactive_indices, close_routes, assignment)

    def AssignmentToRoutes(self, assignment: "Assignment", routes: "std::vector< std::vector< int64 > > *const") -> "void":
        return _pywrapcp.RoutingModel_AssignmentToRoutes(self, assignment, routes)

    def CompactAssignment(self, assignment: "Assignment") -> "operations_research::Assignment *":
        return _pywrapcp.RoutingModel_CompactAssignment(self, assignment)

    def CompactAndCheckAssignment(self, assignment: "Assignment") -> "operations_research::Assignment *":
        return _pywrapcp.RoutingModel_CompactAndCheckAssignment(self, assignment)

    def AddToAssignment(self, var: "IntVar") -> "void":
        return _pywrapcp.RoutingModel_AddToAssignment(self, var)

    def AddIntervalToAssignment(self, interval: "IntervalVar") -> "void":
        return _pywrapcp.RoutingModel_AddIntervalToAssignment(self, interval)

    def PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment: "Assignment", duration_limit: "absl::Duration") -> "operations_research::Assignment const *":
        return _pywrapcp.RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment, duration_limit)

    def AddLocalSearchFilter(self, filter: "LocalSearchFilter") -> "void":
        return _pywrapcp.RoutingModel_AddLocalSearchFilter(self, filter)

    def Start(self, vehicle: "int") -> "int64":
        return _pywrapcp.RoutingModel_Start(self, vehicle)

    def End(self, vehicle: "int") -> "int64":
        return _pywrapcp.RoutingModel_End(self, vehicle)

    def IsStart(self, index: "int64") -> "bool":
        return _pywrapcp.RoutingModel_IsStart(self, index)

    def IsEnd(self, index: "int64") -> "bool":
        return _pywrapcp.RoutingModel_IsEnd(self, index)

    def VehicleIndex(self, index: "int") -> "int":
        return _pywrapcp.RoutingModel_VehicleIndex(self, index)

    def Next(self, assignment: "Assignment", index: "int64") -> "int64":
        return _pywrapcp.RoutingModel_Next(self, assignment, index)

    def IsVehicleUsed(self, assignment: "Assignment", vehicle: "int") -> "bool":
        return _pywrapcp.RoutingModel_IsVehicleUsed(self, assignment, vehicle)

    def NextVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingModel_NextVar(self, index)

    def ActiveVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingModel_ActiveVar(self, index)

    def VehicleCostsConsideredVar(self, vehicle: "int") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingModel_VehicleCostsConsideredVar(self, vehicle)

    def VehicleVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingModel_VehicleVar(self, index)

    def CostVar(self) -> "operations_research::IntVar *":
        return _pywrapcp.RoutingModel_CostVar(self)

    def GetArcCostForVehicle(self, from_index: "int64", to_index: "int64", vehicle: "int64") -> "int64":
        return _pywrapcp.RoutingModel_GetArcCostForVehicle(self, from_index, to_index, vehicle)

    def CostsAreHomogeneousAcrossVehicles(self) -> "bool":
        return _pywrapcp.RoutingModel_CostsAreHomogeneousAcrossVehicles(self)

    def GetHomogeneousCost(self, from_index: "int64", to_index: "int64") -> "int64":
        return _pywrapcp.RoutingModel_GetHomogeneousCost(self, from_index, to_index)

    def GetArcCostForFirstSolution(self, from_index: "int64", to_index: "int64") -> "int64":
        return _pywrapcp.RoutingModel_GetArcCostForFirstSolution(self, from_index, to_index)

    def GetArcCostForClass(self, from_index: "int64", to_index: "int64", cost_class_index: "int64") -> "int64":
        return _pywrapcp.RoutingModel_GetArcCostForClass(self, from_index, to_index, cost_class_index)

    def GetCostClassIndexOfVehicle(self, vehicle: "int64") -> "operations_research::RoutingModel::CostClassIndex":
        return _pywrapcp.RoutingModel_GetCostClassIndexOfVehicle(self, vehicle)

    def HasVehicleWithCostClassIndex(self, cost_class_index: "operations_research::RoutingModel::CostClassIndex") -> "bool":
        return _pywrapcp.RoutingModel_HasVehicleWithCostClassIndex(self, cost_class_index)

    def GetCostClassesCount(self) -> "int":
        return _pywrapcp.RoutingModel_GetCostClassesCount(self)

    def GetNonZeroCostClassesCount(self) -> "int":
        return _pywrapcp.RoutingModel_GetNonZeroCostClassesCount(self)

    def GetVehicleClassIndexOfVehicle(self, vehicle: "int64") -> "operations_research::RoutingModel::VehicleClassIndex":
        return _pywrapcp.RoutingModel_GetVehicleClassIndexOfVehicle(self, vehicle)

    def GetVehicleClassesCount(self) -> "int":
        return _pywrapcp.RoutingModel_GetVehicleClassesCount(self)

    def GetSameVehicleIndicesOfIndex(self, node: "int") -> "std::vector< int > const &":
        return _pywrapcp.RoutingModel_GetSameVehicleIndicesOfIndex(self, node)

    def ArcIsMoreConstrainedThanArc(self, _from: "int64", to1: "int64", to2: "int64") -> "bool":
        return _pywrapcp.RoutingModel_ArcIsMoreConstrainedThanArc(self, _from, to1, to2)

    def DebugOutputAssignment(self, solution_assignment: "Assignment", dimension_to_print: "std::string const &") -> "std::string":
        return _pywrapcp.RoutingModel_DebugOutputAssignment(self, solution_assignment, dimension_to_print)

    def solver(self) -> "operations_research::Solver *":
        return _pywrapcp.RoutingModel_solver(self)

    def CheckLimit(self) -> "bool":
        return _pywrapcp.RoutingModel_CheckLimit(self)

    def RemainingTime(self) -> "absl::Duration":
        return _pywrapcp.RoutingModel_RemainingTime(self)

    def nodes(self) -> "int":
        return _pywrapcp.RoutingModel_nodes(self)

    def vehicles(self) -> "int":
        return _pywrapcp.RoutingModel_vehicles(self)

    def Size(self) -> "int64":
        return _pywrapcp.RoutingModel_Size(self)

    def GetNumberOfDecisionsInFirstSolution(self, search_parameters: "operations_research::RoutingSearchParameters const &") -> "int64":
        return _pywrapcp.RoutingModel_GetNumberOfDecisionsInFirstSolution(self, search_parameters)

    def GetNumberOfRejectsInFirstSolution(self, search_parameters: "operations_research::RoutingSearchParameters const &") -> "int64":
        return _pywrapcp.RoutingModel_GetNumberOfRejectsInFirstSolution(self, search_parameters)

    def GetAutomaticFirstSolutionStrategy(self) -> "operations_research::FirstSolutionStrategy::Value":
        return _pywrapcp.RoutingModel_GetAutomaticFirstSolutionStrategy(self)

    def IsMatchingModel(self) -> "bool":
        return _pywrapcp.RoutingModel_IsMatchingModel(self)

    def MakeGuidedSlackFinalizer(self, dimension: "RoutingDimension", initializer: "std::function< int64 (int64) >") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.RoutingModel_MakeGuidedSlackFinalizer(self, dimension, initializer)

    def MakeSelfDependentDimensionFinalizer(self, dimension: "RoutingDimension") -> "operations_research::DecisionBuilder *":
        return _pywrapcp.RoutingModel_MakeSelfDependentDimensionFinalizer(self, dimension)

    def AddMatrixDimension(self, *args) -> "void":
        return _pywrapcp.RoutingModel_AddMatrixDimension(self, *args)

# Register RoutingModel in _pywrapcp:
_pywrapcp.RoutingModel_swigregister(RoutingModel)
cvar = _pywrapcp.cvar
RoutingModel.kNoPenalty = _pywrapcp.cvar.RoutingModel_kNoPenalty
RoutingModel.kNoDisjunction = _pywrapcp.cvar.RoutingModel_kNoDisjunction
RoutingModel.kNoDimension = _pywrapcp.cvar.RoutingModel_kNoDimension

class RoutingModelVisitor(BaseObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pywrapcp.RoutingModelVisitor_swiginit(self, _pywrapcp.new_RoutingModelVisitor())
    __swig_destroy__ = _pywrapcp.delete_RoutingModelVisitor

# Register RoutingModelVisitor in _pywrapcp:
_pywrapcp.RoutingModelVisitor_swigregister(RoutingModelVisitor)
RoutingModelVisitor.kLightElement = _pywrapcp.cvar.RoutingModelVisitor_kLightElement
RoutingModelVisitor.kLightElement2 = _pywrapcp.cvar.RoutingModelVisitor_kLightElement2
RoutingModelVisitor.kRemoveValues = _pywrapcp.cvar.RoutingModelVisitor_kRemoveValues

class GlobalVehicleBreaksConstraint(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dimension: "RoutingDimension"):
        _pywrapcp.GlobalVehicleBreaksConstraint_swiginit(self, _pywrapcp.new_GlobalVehicleBreaksConstraint(dimension))

    def DebugString(self) -> "std::string":
        return _pywrapcp.GlobalVehicleBreaksConstraint_DebugString(self)

    def Post(self) -> "void":
        return _pywrapcp.GlobalVehicleBreaksConstraint_Post(self)

    def InitialPropagateWrapper(self) -> "void":
        return _pywrapcp.GlobalVehicleBreaksConstraint_InitialPropagateWrapper(self)
    __swig_destroy__ = _pywrapcp.delete_GlobalVehicleBreaksConstraint

# Register GlobalVehicleBreaksConstraint in _pywrapcp:
_pywrapcp.GlobalVehicleBreaksConstraint_swigregister(GlobalVehicleBreaksConstraint)

class TypeRegulationsChecker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_TypeRegulationsChecker

    def CheckVehicle(self, vehicle: "int", next_accessor: "std::function< int64 (int64) > const &") -> "bool":
        return _pywrapcp.TypeRegulationsChecker_CheckVehicle(self, vehicle, next_accessor)

# Register TypeRegulationsChecker in _pywrapcp:
_pywrapcp.TypeRegulationsChecker_swigregister(TypeRegulationsChecker)

class TypeIncompatibilityChecker(TypeRegulationsChecker):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "RoutingModel", check_hard_incompatibilities: "bool"):
        _pywrapcp.TypeIncompatibilityChecker_swiginit(self, _pywrapcp.new_TypeIncompatibilityChecker(model, check_hard_incompatibilities))
    __swig_destroy__ = _pywrapcp.delete_TypeIncompatibilityChecker

# Register TypeIncompatibilityChecker in _pywrapcp:
_pywrapcp.TypeIncompatibilityChecker_swigregister(TypeIncompatibilityChecker)

class TypeRequirementChecker(TypeRegulationsChecker):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "RoutingModel"):
        _pywrapcp.TypeRequirementChecker_swiginit(self, _pywrapcp.new_TypeRequirementChecker(model))
    __swig_destroy__ = _pywrapcp.delete_TypeRequirementChecker

# Register TypeRequirementChecker in _pywrapcp:
_pywrapcp.TypeRequirementChecker_swigregister(TypeRequirementChecker)

class TypeRegulationsConstraint(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, model: "RoutingModel"):
        _pywrapcp.TypeRegulationsConstraint_swiginit(self, _pywrapcp.new_TypeRegulationsConstraint(model))

    def Post(self) -> "void":
        return _pywrapcp.TypeRegulationsConstraint_Post(self)

    def InitialPropagateWrapper(self) -> "void":
        return _pywrapcp.TypeRegulationsConstraint_InitialPropagateWrapper(self)
    __swig_destroy__ = _pywrapcp.delete_TypeRegulationsConstraint

# Register TypeRegulationsConstraint in _pywrapcp:
_pywrapcp.TypeRegulationsConstraint_swigregister(TypeRegulationsConstraint)

class RoutingDimension(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_RoutingDimension

    def model(self) -> "operations_research::RoutingModel *":
        return _pywrapcp.RoutingDimension_model(self)

    def GetTransitValue(self, from_index: "int64", to_index: "int64", vehicle: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_GetTransitValue(self, from_index, to_index, vehicle)

    def GetTransitValueFromClass(self, from_index: "int64", to_index: "int64", vehicle_class: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_GetTransitValueFromClass(self, from_index, to_index, vehicle_class)

    def CumulVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingDimension_CumulVar(self, index)

    def TransitVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingDimension_TransitVar(self, index)

    def FixedTransitVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingDimension_FixedTransitVar(self, index)

    def SlackVar(self, index: "int64") -> "operations_research::IntVar *":
        return _pywrapcp.RoutingDimension_SlackVar(self, index)

    def SetSpanUpperBoundForVehicle(self, upper_bound: "int64", vehicle: "int") -> "void":
        return _pywrapcp.RoutingDimension_SetSpanUpperBoundForVehicle(self, upper_bound, vehicle)

    def SetSpanCostCoefficientForVehicle(self, coefficient: "int64", vehicle: "int") -> "void":
        return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForVehicle(self, coefficient, vehicle)

    def SetSpanCostCoefficientForAllVehicles(self, coefficient: "int64") -> "void":
        return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForAllVehicles(self, coefficient)

    def SetGlobalSpanCostCoefficient(self, coefficient: "int64") -> "void":
        return _pywrapcp.RoutingDimension_SetGlobalSpanCostCoefficient(self, coefficient)

    def SetCumulVarSoftUpperBound(self, index: "int64", upper_bound: "int64", coefficient: "int64") -> "void":
        return _pywrapcp.RoutingDimension_SetCumulVarSoftUpperBound(self, index, upper_bound, coefficient)

    def HasCumulVarSoftUpperBound(self, index: "int64") -> "bool":
        return _pywrapcp.RoutingDimension_HasCumulVarSoftUpperBound(self, index)

    def GetCumulVarSoftUpperBound(self, index: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBound(self, index)

    def GetCumulVarSoftUpperBoundCoefficient(self, index: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundCoefficient(self, index)

    def SetCumulVarSoftLowerBound(self, index: "int64", lower_bound: "int64", coefficient: "int64") -> "void":
        return _pywrapcp.RoutingDimension_SetCumulVarSoftLowerBound(self, index, lower_bound, coefficient)

    def HasCumulVarSoftLowerBound(self, index: "int64") -> "bool":
        return _pywrapcp.RoutingDimension_HasCumulVarSoftLowerBound(self, index)

    def GetCumulVarSoftLowerBound(self, index: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBound(self, index)

    def GetCumulVarSoftLowerBoundCoefficient(self, index: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundCoefficient(self, index)

    def SetBreakIntervalsOfVehicle(self, breaks: "std::vector< operations_research::IntervalVar * >", vehicle: "int", node_visit_transits: "std::vector< int64 >") -> "void":
        return _pywrapcp.RoutingDimension_SetBreakIntervalsOfVehicle(self, breaks, vehicle, node_visit_transits)

    def SetBreakDistanceDurationOfVehicle(self, distance: "int64", duration: "int64", vehicle: "int") -> "void":
        return _pywrapcp.RoutingDimension_SetBreakDistanceDurationOfVehicle(self, distance, duration, vehicle)

    def InitializeBreaks(self) -> "void":
        return _pywrapcp.RoutingDimension_InitializeBreaks(self)

    def HasBreakConstraints(self) -> "bool":
        return _pywrapcp.RoutingDimension_HasBreakConstraints(self)

    def GetPreTravelEvaluatorOfVehicle(self, vehicle: "int") -> "int":
        return _pywrapcp.RoutingDimension_GetPreTravelEvaluatorOfVehicle(self, vehicle)

    def GetPostTravelEvaluatorOfVehicle(self, vehicle: "int") -> "int":
        return _pywrapcp.RoutingDimension_GetPostTravelEvaluatorOfVehicle(self, vehicle)

    def base_dimension(self) -> "operations_research::RoutingDimension const *":
        return _pywrapcp.RoutingDimension_base_dimension(self)

    def ShortestTransitionSlack(self, node: "int64") -> "int64":
        return _pywrapcp.RoutingDimension_ShortestTransitionSlack(self, node)

    def name(self) -> "std::string const &":
        return _pywrapcp.RoutingDimension_name(self)

    def SetPickupToDeliveryLimitFunctionForPair(self, limit_function: "operations_research::RoutingDimension::PickupToDeliveryLimitFunction", pair_index: "int") -> "void":
        return _pywrapcp.RoutingDimension_SetPickupToDeliveryLimitFunctionForPair(self, limit_function, pair_index)

    def HasPickupToDeliveryLimits(self) -> "bool":
        return _pywrapcp.RoutingDimension_HasPickupToDeliveryLimits(self)

    def AddNodePrecedence(self, first_node: "int64", second_node: "int64", offset: "int64") -> "void":
        return _pywrapcp.RoutingDimension_AddNodePrecedence(self, first_node, second_node, offset)

    def GetSpanUpperBoundForVehicle(self, vehicle: "int") -> "int64":
        return _pywrapcp.RoutingDimension_GetSpanUpperBoundForVehicle(self, vehicle)

    def GetSpanCostCoefficientForVehicle(self, vehicle: "int") -> "int64":
        return _pywrapcp.RoutingDimension_GetSpanCostCoefficientForVehicle(self, vehicle)

    def global_span_cost_coefficient(self) -> "int64":
        return _pywrapcp.RoutingDimension_global_span_cost_coefficient(self)

    def GetGlobalOptimizerOffset(self) -> "int64":
        return _pywrapcp.RoutingDimension_GetGlobalOptimizerOffset(self)

    def GetLocalOptimizerOffsetForVehicle(self, vehicle: "int") -> "int64":
        return _pywrapcp.RoutingDimension_GetLocalOptimizerOffsetForVehicle(self, vehicle)

# Register RoutingDimension in _pywrapcp:
_pywrapcp.RoutingDimension_swigregister(RoutingDimension)


def MakeSetValuesFromTargets(solver: "Solver", variables: "std::vector< operations_research::IntVar * >", targets: "std::vector< int64 >") -> "operations_research::DecisionBuilder *":
    return _pywrapcp.MakeSetValuesFromTargets(solver, variables, targets)

def SolveModelWithSat(model: "RoutingModel", search_parameters: "operations_research::RoutingSearchParameters const &", initial_solution: "Assignment", solution: "Assignment") -> "bool":
    return _pywrapcp.SolveModelWithSat(model, search_parameters, initial_solution, solution)
class BasePathFilter(IntVarLocalSearchFilter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_BasePathFilter

    def Accept(self, delta: "Assignment", deltadelta: "Assignment", objective_min: "int64", objective_max: "int64") -> "bool":
        return _pywrapcp.BasePathFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def OnSynchronize(self, delta: "Assignment") -> "void":
        return _pywrapcp.BasePathFilter_OnSynchronize(self, delta)

# Register BasePathFilter in _pywrapcp:
_pywrapcp.BasePathFilter_swigregister(BasePathFilter)

class CPFeasibilityFilter(IntVarLocalSearchFilter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, routing_model: "RoutingModel"):
        _pywrapcp.CPFeasibilityFilter_swiginit(self, _pywrapcp.new_CPFeasibilityFilter(routing_model))
    __swig_destroy__ = _pywrapcp.delete_CPFeasibilityFilter

    def DebugString(self) -> "std::string":
        return _pywrapcp.CPFeasibilityFilter_DebugString(self)

    def Accept(self, delta: "Assignment", deltadelta: "Assignment", objective_min: "int64", objective_max: "int64") -> "bool":
        return _pywrapcp.CPFeasibilityFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def OnSynchronize(self, delta: "Assignment") -> "void":
        return _pywrapcp.CPFeasibilityFilter_OnSynchronize(self, delta)

# Register CPFeasibilityFilter in _pywrapcp:
_pywrapcp.CPFeasibilityFilter_swigregister(CPFeasibilityFilter)



